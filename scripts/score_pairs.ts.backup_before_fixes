#!/usr/bin/env -S npx tsx
/**
 * Pair Scoring Framework for MM Bot
 * 
 * Evaluates trading pairs using 5 key metrics:
 * 1. PPK - Profit Per 1000 submits
 * 2. Fill Rate - Quality of spreads
 * 3. PVU - Profit per Volatility Unit
 * 4. PFE - Profit per Fee efficiency
 * 5. Max Drawdown - Intraday risk
 */

import { execSync } from "child_process";
import * as fs from "fs";
import * as path from "path";

interface PairMetrics {
  pair: string;
  submits: number;
  fills: number;
  fillRate: number;
  pnl: number;
  ppk: number; // Profit Per 1000 submits
  maxDrawdown: number;
  riskEvents: number;
  score: number;
}

const LOOKBACK_HOURS = 10;
const PAIRS = ["ZEC", "UNI"];

function getSubmitCount(pair: string): number {
  try {
    const since = new Date(Date.now() - LOOKBACK_HOURS * 60 * 60 * 1000).toISOString().slice(0, 19).replace("T", " ");
    const cmd = `journalctl -u mm-bot.service --since "${since}" --no-pager 2>/dev/null | grep -c "submit: pair=${pair}" || echo 0`;
    const result = execSync(cmd, { encoding: "utf8" }).trim();
    return parseInt(result) || 0;
  } catch (err) {
    return 0;
  }
}

function getFillCount(): number {
  try {
    const since = new Date(Date.now() - LOOKBACK_HOURS * 60 * 60 * 1000).toISOString().slice(0, 19).replace("T", " ");
    const cmd = `journalctl -u mm-bot.service --since "${since}" --no-pager 2>/dev/null | grep -oE "Synced [0-9]+ new fills" | awk "{sum+=\\$2} END{print sum+0}"`;
    const result = execSync(cmd, { encoding: "utf8" }).trim();
    return parseInt(result) || 0;
  } catch (err) {
    return 0;
  }
}

function getPnLFromLogs(): number {
  try {
    const since = new Date(Date.now() - LOOKBACK_HOURS * 60 * 60 * 1000).toISOString().slice(0, 19).replace("T", " ");
    // Fixed: Use awk to split by $ and sum the second field
    const cmd = `journalctl -u mm-bot.service --since "${since}" --no-pager 2>/dev/null | grep "Synced.*new fills" | awk -F"$" "{sum+=\\$2} END{print sum+0}"`;
    const result = execSync(cmd, { encoding: "utf8" }).trim();
    return parseFloat(result) || 0;
  } catch (err) {
    return 0;
  }
}

function getMaxDrawdown(pair: string): number {
  try {
    const shadowLogPath = "data/risk_shadow.log";
    if (!fs.existsSync(shadowLogPath)) return 0;
    
    const since = Date.now() - LOOKBACK_HOURS * 60 * 60 * 1000;
    const lines = fs.readFileSync(shadowLogPath, "utf8").split("\\n");
    
    let maxDrawdown = 0;
    for (const line of lines) {
      if (!line.trim()) continue;
      try {
        const data = JSON.parse(line);
        const ts = new Date(data.ts).getTime();
        if (ts < since) continue;
        if (data.pair !== pair) continue;
        
        const upnl = parseFloat(data.unrealizedPnlUsd);
        if (upnl < maxDrawdown) {
          maxDrawdown = upnl;
        }
      } catch (e) {
        // Skip invalid lines
      }
    }
    
    return Math.abs(maxDrawdown);
  } catch (err) {
    return 0;
  }
}

function getRiskEventCount(pair: string): number {
  try {
    const shadowLogPath = "data/risk_shadow.log";
    if (!fs.existsSync(shadowLogPath)) return 0;
    
    const since = Date.now() - LOOKBACK_HOURS * 60 * 60 * 1000;
    const lines = fs.readFileSync(shadowLogPath, "utf8").split("\\n");
    
    let count = 0;
    for (const line of lines) {
      if (!line.trim()) continue;
      try {
        const data = JSON.parse(line);
        const ts = new Date(data.ts).getTime();
        if (ts < since) continue;
        if (data.pair !== pair) continue;
        count++;
      } catch (e) {
        // Skip invalid lines
      }
    }
    
    return count;
  } catch (err) {
    return 0;
  }
}

function calculateScore(metrics: Omit<PairMetrics, "score">): number {
  // Scoring weights:
  // PPK: 40% (most important)
  // Fill Rate: 20%
  // Max Drawdown: 25% (risk is critical)
  // Risk Events: 15%
  
  let score = 0;
  
  // PPK score (0-40 points)
  if (metrics.ppk > 50) score += 40;
  else if (metrics.ppk > 30) score += 35;
  else if (metrics.ppk > 15) score += 25;
  else if (metrics.ppk > 5) score += 10;
  
  // Fill rate score (0-20 points)
  if (metrics.fillRate >= 20 && metrics.fillRate <= 35) score += 20;
  else if (metrics.fillRate >= 15 && metrics.fillRate <= 40) score += 15;
  else if (metrics.fillRate >= 10) score += 10;
  
  // Max drawdown score (0-25 points) - lower is better
  if (metrics.maxDrawdown < 30) score += 25;
  else if (metrics.maxDrawdown < 50) score += 20;
  else if (metrics.maxDrawdown < 100) score += 10;
  else if (metrics.maxDrawdown < 200) score += 5;
  
  // Risk events score (0-15 points) - lower is better
  const riskEventsPerHour = metrics.riskEvents / LOOKBACK_HOURS;
  if (riskEventsPerHour < 0.5) score += 15;
  else if (riskEventsPerHour < 1) score += 10;
  else if (riskEventsPerHour < 2) score += 5;
  
  return Math.round(score);
}

function getRating(score: number): { symbol: string; text: string; recommendations: string[] } {
  if (score >= 70) {
    return {
      symbol: "âœ…",
      text: "EXCELLENT - Keep trading",
      recommendations: []
    };
  } else if (score >= 50) {
    return {
      symbol: "ğŸ‘",
      text: "GOOD - Solid performer",
      recommendations: []
    };
  } else if (score >= 30) {
    return {
      symbol: "âš ï¸",
      text: "MARGINAL - Monitor closely",
      recommendations: []
    };
  } else {
    return {
      symbol: "âŒ",
      text: "POOR - Consider replacing this pair",
      recommendations: []
    };
  }
}

// Main execution
async function main() {
  console.log("\\nğŸ’° Pair Scoring Framework - 10h Lookback\\n");
  
  const totalPnl = getPnLFromLogs();
  const totalFills = getFillCount();
  
  console.log(`ğŸ’° Total PnL (10h): $${totalPnl.toFixed(2)}`);
  console.log(`ğŸ“¥ Total Fills: ${totalFills}`);
  console.log("");
  
  const results: PairMetrics[] = [];
  
  for (const pair of PAIRS) {
    const submits = getSubmitCount(pair);
    const maxDrawdown = getMaxDrawdown(pair);
    const riskEvents = getRiskEventCount(pair);
    
    // Approximate fills per pair (evenly split for now)
    const fills = Math.round((totalFills / PAIRS.length) * (submits / PAIRS.reduce((sum, p) => sum + getSubmitCount(p), 0) || 1));
    
    // Approximate PnL per pair (evenly split for now)
    const pnl = totalPnl / PAIRS.length;
    
    const fillRate = submits > 0 ? (fills / submits) * 100 : 0;
    const ppk = submits > 0 ? (pnl / submits) * 1000 : 0;
    
    const metricsWithoutScore: Omit<PairMetrics, "score"> = {
      pair,
      submits,
      fills,
      fillRate,
      pnl,
      ppk,
      maxDrawdown,
      riskEvents
    };
    
    const score = calculateScore(metricsWithoutScore);
    
    results.push({ ...metricsWithoutScore, score });
  }
  
  // Sort by score descending
  results.sort((a, b) => b.score - a.score);
  
  // Display results
  console.log("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
  console.log("â”‚                    PAIR RANKING                             â”‚");
  console.log("â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
  console.log("â”‚ Pair â”‚ Submits â”‚ Fill %   â”‚ PPK  â”‚ Draw â”‚ Risks   â”‚ SCORE  â”‚");
  console.log("â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
  
  for (const r of results) {
    const pairPad = r.pair.padEnd(4);
    const submitsPad = r.submits.toString().padStart(7);
    const fillRatePad = `${r.fillRate.toFixed(1)}%`.padStart(8);
    const ppkPad = r.ppk.toFixed(0).padStart(4);
    const drawPad = r.maxDrawdown.toFixed(0).padStart(4);
    const risksPad = r.riskEvents.toString().padStart(7);
    const scorePad = r.score.toString().padStart(6);
    
    console.log(`â”‚    ${pairPad} â”‚ ${submitsPad} â”‚ ${fillRatePad} â”‚ ${ppkPad} â”‚ ${drawPad} â”‚ ${risksPad} â”‚ ${scorePad} â”‚`);
  }
  
  console.log("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜");
  console.log("");
  
  console.log("ğŸ“Œ RECOMMENDATIONS:\\n");
  for (const r of results) {
    const rating = getRating(r.score);
    console.log(`${r.pair}:`);
    console.log(`  ${rating.symbol} ${rating.text}`);
    
    if (r.ppk < 10) console.log("  âš ï¸  Low profitability (PPK: " + r.ppk.toFixed(0) + ")");
    if (r.fillRate < 15 || r.fillRate > 40) console.log(`  âš ï¸  Suboptimal fill rate (${r.fillRate.toFixed(1)}%)`);
    if (r.maxDrawdown > 100) console.log(`  âš ï¸  High drawdown risk ($${r.maxDrawdown.toFixed(0)})`);
    if (r.riskEvents > 50) console.log(`  âš ï¸  Frequent risk events (${r.riskEvents})`);
    
    console.log("");
  }
}

main().catch(console.error);
