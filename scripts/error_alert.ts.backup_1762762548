/**
 * error_alert.ts
 *
 * Co godzinÄ™:
 *  - czyta ostatnie ~500 linii z pm2 logs mm-bot
 *  - znajduje wszystkie quant_evt=submit
 *  - zlicza err!=none (globalnie i per typ)
 *  - zapisuje metryki do ./alerts/
 *  - na podstawie progÃ³w wysyÅ‚a alert na Slack
 *
 * Progi:
 *   SPECJALNE:
 *     invalid_size >= 3          â†’ ðŸš¨ CRITICAL
 *     invalid_size >= 1          â†’ âš ï¸ WARNING
 *     insufficient_margin >= 3   â†’ ðŸš¨ CRITICAL
 *     insufficient_margin >= 1   â†’ âš ï¸ WARNING
 *
 *   OGÃ“LNE (jeÅ›li powyÅ¼sze nie zadziaÅ‚ajÄ…):
 *     0â€“2 bÅ‚Ä™dy  â†’ tylko log na serwerze
 *     3â€“5 bÅ‚Ä™dÃ³w â†’ âš ï¸  Slack WARNING
 *     >5 bÅ‚Ä™dÃ³w  â†’ ðŸš¨  Slack CRITICAL
 */

import { execSync } from 'node:child_process'
import { existsSync, mkdirSync, writeFileSync } from 'node:fs'
import { join } from 'node:path'

type ErrorStats = {
  totalErrors: number
  byType: Record<string, number>
  totalSubmits: number
}

function getSlackWebhook(): string | null {
  const fromUrl = process.env.SLACK_WEBHOOK_URL
  const fromGeneric = process.env.SLACK_WEBHOOK
  return fromUrl || fromGeneric || null
}

function parseErrorStats(logText: string): ErrorStats {
  const lines = logText.split('\n')
  const byType: Record<string, number> = {}
  let totalErrors = 0
  let totalSubmits = 0

  const submitRe = /quant_evt=submit\b.*?\berr=([a-zA-Z0-9_]+)/

  for (const line of lines) {
    const m = line.match(submitRe)
    if (!m) continue

    totalSubmits++
    const err = m[1]

    if (err !== 'none') {
      totalErrors++
      byType[err] = (byType[err] || 0) + 1
    }
  }

  return { totalErrors, byType, totalSubmits }
}

async function postToSlack(webhook: string, text: string) {
  try {
    execSync(`curl -sS -X POST -H Content-Type: application/json --data '${JSON.stringify({ text })}' ${webhook}`, {
      encoding: 'utf8'
    })
  } catch (e) {
    throw new Error(`Failed to post to Slack: ${e}`)
  }
}

function formatSlackMessage(
  stats: ErrorStats,
  level: 'warn' | 'critical',
  reasons: string[]
): string {
  const prefix =
    level === 'critical'
      ? 'ðŸš¨ *MM Bot Error Alert (CRITICAL)*'
      : 'âš ï¸ *MM Bot Error Alert*'

  const { totalErrors, byType, totalSubmits } = stats

  const lines: string[] = []
  lines.push(`${prefix}`)
  lines.push('')
  lines.push(
    `Detected *${totalErrors}* order submission error(s) in the last check.`
  )
  if (totalSubmits > 0) {
    const pct = ((totalErrors / totalSubmits) * 100).toFixed(1)
    lines.push(
      `Total submits seen: *${totalSubmits}* (error rate: *${pct}%*).`
    )
  }
  lines.push('')
  if (reasons.length > 0) {
    lines.push('*Alert reasons:*')
    reasons.forEach((r) => lines.push(`â€¢ ${r}`))
    lines.push('')
  }
  lines.push('*Error breakdown:*')
  Object.entries(byType)
    .sort((a, b) => b[1] - a[1])
    .forEach(([err, count]) => {
      lines.push(`â€¢ \`${err}\`: *${count}*`)
    })

  lines.push('')
  lines.push('Check logs on server: `mm-logs-focus`')
  lines.push('Server: `root@207.246.92.212`')

  return lines.join('\n')
}

function ensureAlertsDir(): string {
  const dir = join(process.cwd(), 'alerts')
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true })
  }
  return dir
}

function persistStats(stats: ErrorStats) {
  const alertsDir = ensureAlertsDir()
  const timestamp = new Date().toISOString()

  const payload = {
    timestamp,
    totalErrors: stats.totalErrors,
    totalSubmits: stats.totalSubmits,
    byType: stats.byType
  }

  // Ostatni snapshot
  const latestPath = join(alertsDir, 'error_stats_latest.json')
  writeFileSync(latestPath, JSON.stringify(payload, null, 2) + '\n', {
    encoding: 'utf8'
  })

  // Historia (JSONL â€“ 1 linia = 1 uruchomienie)
  const historyPath = join(alertsDir, 'error_stats_history.log')
  writeFileSync(historyPath, JSON.stringify(payload) + '\n', {
    encoding: 'utf8',
    flag: 'a'
  })
}

function decideAlertLevel(
  stats: ErrorStats
): { level: 'none' | 'warn' | 'critical'; reasons: string[] } {
  const { totalErrors, byType } = stats
  let level: 'none' | 'warn' | 'critical' = 'none'
  const reasons: string[] = []

  const invalid = byType['invalid_size'] || 0
  const margin = byType['insufficient_margin'] || 0

  // Specjalne traktowanie invalid_size
  if (invalid >= 3) {
    level = 'critical'
    reasons.push('invalid_size >= 3')
  } else if (invalid >= 1) {
    if (level === 'none') level = 'warn'
    reasons.push('invalid_size >= 1')
  }

  // Specjalne traktowanie insufficient_margin
  if (margin >= 3) {
    level = 'critical'
    reasons.push('insufficient_margin >= 3')
  } else if (margin >= 1) {
    if (level === 'none') level = 'warn'
    reasons.push('insufficient_margin >= 1')
  }

  // OgÃ³lne progi, tylko jeÅ›li nic specjalnego nie zapaliÅ‚o level
  if (level === 'none') {
    if (totalErrors >= 3 && totalErrors <= 5) {
      level = 'warn'
      reasons.push('totalErrors between 3 and 5')
    } else if (totalErrors > 5) {
      level = 'critical'
      reasons.push('totalErrors > 5')
    }
  }

  return { level, reasons }
}

async function main() {
  console.log('[ERROR ALERT] Checking logs for errors (last 500 lines)...')

  let logs: string
  try {
    logs = execSync('pm2 logs mm-bot --lines 500 --nostream', {
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'pipe']
    })
  } catch (e) {
    console.error('[ERROR ALERT] Failed to read pm2 logs:', e)
    return
  }

  const stats = parseErrorStats(logs)
  const { totalErrors, byType, totalSubmits } = stats

  // Zapisz metryki do ./alerts/ niezaleÅ¼nie od tego, czy bÄ™dzie Slack, czy nie
  persistStats(stats)

  if (totalSubmits === 0) {
    console.log(
      '[ERROR ALERT] No quant_evt=submit events found in last 500 lines (bot idle?).'
    )
    return
  }

  if (totalErrors === 0) {
    console.log('[ERROR ALERT] No errors detected - all good!')
    return
  }

  console.log(
    `[ERROR ALERT] Found ${totalErrors} error(s) out of ${totalSubmits} submits.`
  )
  console.log('[ERROR ALERT] Breakdown:', byType)

  const { level, reasons } = decideAlertLevel(stats)

  if (level === 'none') {
    console.log(
      '[ERROR ALERT] Error count / types below thresholds - no Slack alert sent.'
    )
    return
  }

  const webhook = getSlackWebhook()
  if (!webhook) {
    console.warn(
      '[ERROR ALERT] SLACK_WEBHOOK / SLACK_WEBHOOK_URL is not set - cannot send alert.'
    )
    return
  }

  const msg = formatSlackMessage(stats, level === 'warn' ? 'warn' : 'critical', reasons)

  try {
    await postToSlack(webhook, msg)
    console.log(
      `[ERROR ALERT] Slack alert sent (level=${level}, totalErrors=${totalErrors}).`
    )
  } catch (e) {
    console.error('[ERROR ALERT] Failed to send Slack alert:', e)
  }
}

main().catch((e) => {
  console.error('[ERROR ALERT] Unhandled error in script:', e)
})
