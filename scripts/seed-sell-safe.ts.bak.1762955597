import * as hl from "@nktkas/hyperliquid";
import { readFileSync } from "fs";
import { join } from "path";
import "dotenv/config";

type Meta = Awaited<ReturnType<hl.InfoClient["meta"]>>;

function qSize(sz:number, lot:number, szDec:number){
  const q = Math.max(lot, Math.floor(sz / lot) * lot);
  const s = Math.max(lot, q);
  return parseFloat(s.toFixed(szDec));
}
function roundToTick(px:number, tick:number){
  if (!isFinite(px) || tick<=0) return px;
  return Math.round(px / tick) * tick;
}

async function ensureAskForCoin(
  ex: hl.ExchangeClient,
  info: hl.InfoClient,
  meta: Meta,
  coin: string,
  targetNotionalUSD: number,
  spreadBps: number,
  walletAddr: string
){
  const uIdx = meta.universe.findIndex(u => u.name === coin);
  if (uIdx < 0) {
    console.log(`[${coin}] skip: not in universe`);
    return;
  }
  const u = meta.universe[uIdx];
  const lot = Math.pow(10, - (u.szDecimals ?? 3));
  const tick = Math.pow(10, - (u.pxDecimals ?? 2));

  const l2 = await info.l2Book({ coin });
  if (!l2 || !l2.levels || l2.levels.length < 2) {
    console.log(`[${coin}] skip: no l2 data`);
    return;
  }
  
  // l2.levels[0] = asks, l2.levels[1] = bids
  const bestAsk = l2.levels[0]?.[0] ? parseFloat(l2.levels[0][0].px) : 0;
  const bestBid = l2.levels[1]?.[0] ? parseFloat(l2.levels[1][0].px) : 0;
  
  if (bestAsk <= 0 || bestBid <= 0) {
    console.log(`[${coin}] skip: invalid prices (ask=${bestAsk}, bid=${bestBid})`);
    return;
  }
  
  const mid = (bestAsk + bestBid) / 2;

  if (!isFinite(mid) || mid<=0){
    console.log(`[${coin}] skip: no mid`);
    return;
  }

  const pxRaw = mid * (1 + spreadBps/10000);
  const px = roundToTick(pxRaw, tick);

  const szRaw = targetNotionalUSD / px;
  const sz = qSize(szRaw, lot, u.szDecimals ?? 3);
  if (!isFinite(sz) || sz <= 0){
    console.log(`[${coin}] fail: computed size <= 0 (px=${px}, notional=${targetNotionalUSD})`);
    return;
  }

  try {
    const oo = await info.openOrders({ user: walletAddr });
    const mine = (oo?.openOrders || []).filter((o:any)=>o.coin===coin && (o.side==="sell" || o.isBuy===false));
    if (mine.length>0){
      console.log(`[${coin}] ok: ASK already present (${mine.length})`);
      return;
    }
  } catch (err) {
    console.log(`[${coin}] warn: could not check existing orders`, err);
  }

  const payload: hl.OrderRequest = {
    action: "Order",
    orders: [{
      a: uIdx,
      s: String(sz),
      p: String(px),
      b: false,
      t: { limit: { tif: "Gtc" } },
      r: false
    }]
  };

  const res = await ex.order(payload);
  const ok = (res as any)?.status==="ok" || (res as any)?.status==="accepted";
  console.log(`[${coin}] seed ASK @${px} sz=${sz} notionalâ‰ˆ${(sz*px).toFixed(2)} status=${ok?"ok":"err"}`);
}

async function main(){
  const transport = new hl.HttpTransport();
  const info = new hl.InfoClient({ transport });
  const meta = await info.meta();
  const ex = new hl.ExchangeClient({
    wallet: process.env.HL_PK || process.env.PRIVATE_KEY || "",
    transport
  });

  const walletAddr = process.env.WALLET_ADDRESS || process.env.WALLET_ADDR || process.env.HL_WALLET || "";
  const targetNotionalUSD = parseFloat(process.env.SEED_SELL_NOTIONAL_USD || "50");
  const spreadBps = parseFloat(process.env.SEED_SELL_SPREAD_BPS || "8");

  const effPath = join(process.cwd(), "runtime/effective_active_pairs.json");
  const eff = JSON.parse(readFileSync(effPath, "utf8"));
  const coins: string[] = (eff?.pairs || []).map((x:string)=>String(x).toUpperCase());

  for (const c of coins){
    try { await ensureAskForCoin(ex, info, meta, c, targetNotionalUSD, spreadBps, walletAddr); }
    catch(e){ console.log(`[${c}] error`, e); }
  }
}
main().catch(e=>{ console.error(e); process.exit(1); });
