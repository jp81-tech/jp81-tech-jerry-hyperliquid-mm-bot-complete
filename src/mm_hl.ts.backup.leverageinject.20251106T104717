import 'dotenv/config'
import fs from 'fs'
import path from 'path'
import { HyperliquidAPI, VolatilityScore } from './api/hyperliquid.js'
import { VolatilityRotation } from './utils/volatility_rotation.js'
import { Supervisor, SupervisorHooks } from './supervisor/index.js'
import { ConsoleNotifier } from './utils/notifier.js'
import { positionSizeUSD } from './utils/position_sizing.js'
import { killSwitchActive } from './utils/kill_switch.js'
import { getNansenProAPI, CopyTradingSignal } from './integrations/nansen_pro.js'
import { OrderReporter } from './utils/order_reporter.js'
import { loadActivePairs } from './selection/active_pairs_consumer.js'
import {
  roundToTick,
  roundToLot,
  getInstrumentSpecs,
  calculateInventorySkew,
  ChaseConfig,
  INSTITUTIONAL_PRESET,
  VolatilityTracker,
  ThrottleTracker
} from './utils/chase.js'
import { HyperliquidWebSocket, L2BookUpdate } from './utils/websocket_client.js'
import { RateLimitReserver } from './utils/rate_limit_reserve.js'
import { GridManager, GridOrder } from './utils/grid_manager.js'
import { createLegacyUnwinderFromEnv, LegacyUnwinder, LegacyPosition } from './utils/legacy_unwinder.js'
import * as hl from '@nktkas/hyperliquid'
import { ethers } from 'ethers'

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SHARED CONSTANTS & HELPERS - Centralized rounding logic
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const EPS = 1e-12

/**
 * Guess szDecimals from mid price (until exchange provides true decimals)
 * High-price assets need fewer decimals to avoid sub-lot rounding
 */
function guessSzDecimals(midPx: number): number {
  return midPx > 100 ? 2 : midPx > 10 ? 3 : 4
}

/**
 * Compute coin step (minimum valid size increment)
 * @param specs - Instrument specs with lotSize
 * @param szDec - Size decimals (from exchange or guessed)
 * @returns Minimum coin increment
 */
function coinStepFrom(specs: { lotSize?: number }, szDec: number): number {
  return Math.max(specs.lotSize ?? 0, Math.pow(10, -szDec))
}

/**
 * Quantize to step with floor rounding (exact decimals, integer arithmetic)
 */
function quantizeFloor(x: number, step: number): number {
  if (step <= 0) return x
  // Use integer arithmetic to avoid float crumbs
  const numSteps = Math.floor((x + 1e-12) / step)
  const decimals = Math.max(0, -Math.floor(Math.log10(step)))
  const multiplier = Math.pow(10, decimals)
  const stepInt = Math.round(step * multiplier)
  const result = (numSteps * stepInt) / multiplier
  return Number(result.toFixed(decimals))
}

/**
 * Quantize to step with ceiling rounding (exact decimals, integer arithmetic)
 */
function quantizeCeil(x: number, step: number): number {
  if (step <= 0) return x
  // Use integer arithmetic to avoid float crumbs
  const numSteps = Math.ceil((x - 1e-12) / step)
  const decimals = Math.max(0, -Math.floor(Math.log10(step)))
  const multiplier = Math.pow(10, decimals)
  const stepInt = Math.round(step * multiplier)
  const result = (numSteps * stepInt) / multiplier
  return Number(result.toFixed(decimals))
}

/**
 * Get decimal precision from tick size
 */
function priceDecimalsFromTick(tickSize: number): number {
  return Math.max(0, -Math.floor(Math.log10(tickSize)))
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CHILD ORDER NORMALIZER - Ensures all orders meet minimum notional requirements
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Re-buckets child orders to ensure each meets minimum notional requirements
 * while preserving total capital allocation.
 *
 * @param orders - Array of grid orders from GridManager
 * @param opts - Target and minimum USD amounts per order
 * @returns Rebucketed orders that all meet minimum notional floor
 */
function normalizeChildNotionals(
  orders: Array<{ price: number; sizeUsd: number; side: "bid" | "ask"; layer: number; units: number }>,
  opts: { targetUsd: number; minUsd: number }
) {
  const target = Math.max(opts.targetUsd, opts.minUsd + 2); // keep ~$2 buffer above exchange floor
  const total = orders.reduce((a, o) => a + (o.sizeUsd || 0), 0);
  if (total <= 0) return [];

  // How many children can we afford at â‰¥ target?
  let slots = Math.floor(total / target);
  if (slots <= 0) {
    // Not enough budget to create even one child above min â†’ pick the largest order only if it clears min
    const best = orders.reduce((acc, o) => (o.sizeUsd > (acc?.sizeUsd ?? 0) ? o : acc), orders[0]);
    if (!best || best.sizeUsd + 1e-9 < opts.minUsd) return [];
    // Allocate all budget to this order (capped by its price conversion later)
    return [{ ...best, sizeUsd: Math.max(opts.minUsd, Math.min(best.sizeUsd, total)) }];
  }

  // Preserve order of original children (sorted by layer then distance typically).
  const rebuilt: typeof orders = [];
  let remaining = total;

  for (let i = 0; i < orders.length && slots > 0; i++) {
    const o = orders[i];
    // ensure we leave enough to fund remaining slots at least 'target' each
    const minReserve = (slots - 1) * target;
    const alloc = Math.min(target, Math.max(opts.minUsd, remaining - minReserve));
    if (alloc + 1e-9 >= opts.minUsd) {
      rebuilt.push({ ...o, sizeUsd: alloc });
      remaining -= alloc;
      slots -= 1;
    }
  }
  // ignore any tiny 'remaining' dust < minUsd

  return rebuilt;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STATE MANAGER - Persists bot state to disk
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

type BotState = {
  positions: { [pair: string]: { size: number; entryPrice: number; side: 'long' | 'short' } }
  trades: { ts: number; pair: string; side: string; price: number; size: number; pnl?: number }[]
  dailyPnl: number
  totalPnl: number
  lastResetDate: string
  execStats: { success: number; fail: number; latencies: number[] }
  lastProcessedFillTime?: number  // Track last synced fill to avoid double-counting
  processedFillOids?: string[]  // Track processed order IDs
}

type OrderHistoryEntry = {
  cloid: string  // Our client order ID
  oid?: string  // Exchange order ID (if assigned)
  pair: string
  side: 'buy' | 'sell'
  price: number
  size: number
  timestamp: number
  status: 'placed' | 'modified' | 'cancelled' | 'filled' | 'rejected'
  method: 'place' | 'batchModify' | 'cancel'
}

class StateManager {
  private stateFile: string
  private state: BotState

  constructor(stateFile?: string) {
    this.stateFile = stateFile || path.join(process.cwd(), 'data/bot_state.json')
    this.state = this.loadState()
  }

  private loadState(): BotState {
    try {
      if (fs.existsSync(this.stateFile)) {
        const loaded = JSON.parse(fs.readFileSync(this.stateFile, 'utf8'))
        // Ensure new fields exist
        loaded.lastProcessedFillTime = loaded.lastProcessedFillTime || 0
        loaded.processedFillOids = loaded.processedFillOids || []
        return loaded
      }
    } catch (e) {}
    return {
      positions: {},
      trades: [],
      dailyPnl: 0,
      totalPnl: 0,
      lastResetDate: new Date().toISOString().split('T')[0],
      execStats: { success: 0, fail: 0, latencies: [] },
      lastProcessedFillTime: 0,
      processedFillOids: []
    }
  }

  saveState() {
    // Async non-blocking save for performance
    setImmediate(() => {
      try {
        fs.mkdirSync(path.dirname(this.stateFile), { recursive: true })
        fs.writeFileSync(this.stateFile, JSON.stringify(this.state, null, 2))
      } catch (e) {
        console.error('Failed to save state:', e)
      }
    })
  }

  getState() {
    return this.state
  }

  updatePosition(pair: string, size: number, entryPrice: number, side: 'long' | 'short') {
    if (size === 0) {
      delete this.state.positions[pair]
    } else {
      this.state.positions[pair] = { size, entryPrice, side }
    }
    this.saveState()
  }

  recordTrade(pair: string, side: string, price: number, size: number, pnl?: number) {
    this.state.trades.push({
      ts: Date.now(),
      pair,
      side,
      price,
      size,
      pnl
    })

    // Keep last 1000 trades
    if (this.state.trades.length > 1000) {
      this.state.trades = this.state.trades.slice(-1000)
    }

    if (pnl !== undefined) {
      this.state.dailyPnl += pnl
      this.state.totalPnl += pnl
    }

    this.saveState()
  }

  recordExecution(success: boolean, latencyMs?: number) {
    if (success) {
      this.state.execStats.success++
    } else {
      this.state.execStats.fail++
    }

    if (latencyMs !== undefined) {
      this.state.execStats.latencies.push(latencyMs)
      // Keep last 100 latencies
      if (this.state.execStats.latencies.length > 100) {
        this.state.execStats.latencies = this.state.execStats.latencies.slice(-100)
      }
    }

    this.saveState()
  }

  resetDailyPnl() {
    const today = new Date().toISOString().split('T')[0]
    if (this.state.lastResetDate !== today) {
      this.state.dailyPnl = 0
      this.state.lastResetDate = today
      this.saveState()
    }
  }

  /**
   * Sync PnL from Hyperliquid fills - uses exchange's reported closedPnl
   * This is the SOURCE OF TRUTH for PnL tracking
   */
  async syncPnLFromHyperliquid(infoClient: hl.InfoClient, walletAddress: string): Promise<{newFills: number, pnlDelta: number}> {
    try {
      // Fetch all fills from Hyperliquid
      const fills = await infoClient.userFills({ user: walletAddress })

      if (!fills || fills.length === 0) {
        return { newFills: 0, pnlDelta: 0 }
      }

      const today = new Date()
      today.setHours(0, 0, 0, 0)

      // Initialize processedFillOids if not exists
      if (!this.state.processedFillOids) {
        this.state.processedFillOids = []
      }

      let newFills = 0
      let pnlDelta = 0

      // Process fills newest to oldest
      for (const fill of fills) {
        // Skip if already processed
        if (this.state.processedFillOids!.includes(fill.oid)) {
          continue
        }

        const fillTime = new Date(fill.time)
        const closedPnl = parseFloat(fill.closedPnl || '0')
        const fee = parseFloat(fill.fee)

        // Net PnL includes fees (fees are negative, so we add them)
        const netPnl = closedPnl + fee  // fee is already negative

        // Add to total PnL
        this.state.totalPnl += netPnl

        // Add to daily PnL if from today
        if (fillTime >= today) {
          this.state.dailyPnl += netPnl
        }

        pnlDelta += netPnl
        newFills++

        // Mark as processed
        this.state.processedFillOids!.push(fill.oid)

        // Record in trades list
        this.state.trades.push({
          ts: fillTime.getTime(),
          pair: fill.coin,
          side: fill.side,
          price: parseFloat(fill.px),
          size: parseFloat(fill.sz),
          pnl: netPnl
        })
      }

      // Keep only last 10000 processed OIDs to prevent unlimited growth
      if (this.state.processedFillOids!.length > 10000) {
        this.state.processedFillOids = this.state.processedFillOids!.slice(-10000)
      }

      // Keep last 1000 trades
      if (this.state.trades.length > 1000) {
        this.state.trades = this.state.trades.slice(-1000)
      }

      this.saveState()
      return { newFills, pnlDelta }

    } catch (error) {
      console.error('Error syncing PnL from Hyperliquid:', error)
      return { newFills: 0, pnlDelta: 0 }
    }
  }

  getExecStats() {
    const { success, fail, latencies} = this.state.execStats
    const avgLatency = latencies.length > 0
      ? latencies.reduce((a, b) => a + b, 0) / latencies.length
      : 0
    return {
      lastN: success + fail,
      success,
      fail,
      avgLatencyMs: avgLatency
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PAPER TRADING - Simulates order execution
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PaperTrading implements TradingInterface {
  private makerFeeBps = 1.5  // 0.015% maker fee
  private takerFeeBps = 4.5  // 0.045% taker fee

      const leverage = Number(process.env.DEFAULT_LEVERAGE || 1);
      order.leverage = leverage;
  async placeOrder(
    pair: string,
    side: 'buy' | 'sell',
    price: number,
    sizeUsd: number,
    orderType: 'limit' | 'market' = 'limit'
  ): Promise<{ success: boolean; fillPrice?: number; fee?: number }> {
    // Simulate realistic fill probability
    const fillProb = orderType === 'market' ? 0.95 : 0.7

    if (Math.random() > fillProb) {
      return { success: false }
    }

    // Simulate slippage for market orders
    let fillPrice = price
    if (orderType === 'market') {
      const slippageBps = Math.random() * 10 // 0-10 bps slippage
      fillPrice = side === 'buy'
        ? price * (1 + slippageBps / 10000)
        : price * (1 - slippageBps / 10000)
    }

    // Calculate fees
    const feeBps = orderType === 'limit' ? this.makerFeeBps : this.takerFeeBps
    const fee = sizeUsd * feeBps / 10000

    return { success: true, fillPrice, fee }
  }

  async cancelOrder(orderId: string): Promise<boolean> {
    return Math.random() > 0.05 // 95% cancel success rate
  }

  async getPosition(pair: string): Promise<{ size: number; entryPrice: number } | null> {
    // Will be managed by StateManager
    return null
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LIVE TRADING - Real Hyperliquid SDK integration
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

interface TradingInterface {
  placeOrder(
    pair: string,
    side: 'buy' | 'sell',
    price: number,
    sizeUsd: number,
    orderType: 'limit' | 'market'
  ): Promise<{ success: boolean; fillPrice?: number; fee?: number }>
  cancelOrder(orderId: string): Promise<boolean>
  getPosition(pair: string): Promise<{ size: number; entryPrice: number } | null>
}

class LiveTrading implements TradingInterface {
  private exchClient: hl.ExchangeClient
  private infoClient: hl.InfoClient
  private api: HyperliquidAPI
  private assetMap: Map<string, number> = new Map()
  private assetDecimals: Map<string, number> = new Map()
  private walletAddress: string
  private makerFeeBps = 1.5  // 0.015% maker fee
  private takerFeeBps = 4.5  // 0.045% taker fee
  private enablePostOnly: boolean = false  // Post-only (ALO) orders
  private cloidCounter: number = Date.now()  // Client Order ID counter
  private orderCloidMap: Map<string, string> = new Map()  // Maps cloid -> oid
  private deadManSwitchActive: boolean = false  // Dead Man's Switch status
  private orderHistory: OrderHistoryEntry[] = []  // Complete order history with cloid
  private chaseConfig: ChaseConfig | null = null  // Institutional chase mode configuration

  // Tier 2/3: Advanced trackers
  private volatilityTracker: Map<string, VolatilityTracker> = new Map()
  private throttleTracker: ThrottleTracker = new ThrottleTracker()
  private lastFillPrice: Map<string, number> = new Map()  // Track last fill for price bands

  // WebSocket & Rate Limit
  private websocket: HyperliquidWebSocket | null = null
  private rateLimitReserver: RateLimitReserver | null = null
  private l2BookCache: Map<string, L2BookUpdate> = new Map()  // Cache latest L2 book data

  constructor(privateKey: string, api: HyperliquidAPI, chaseConfig: ChaseConfig | null = null) {
    if (!privateKey) {
      throw new Error('Private key required for live trading')
    }

    this.chaseConfig = chaseConfig
    this.api = api

    // Initialize clients
    this.exchClient = new hl.ExchangeClient({
      wallet: privateKey,
      transport: new hl.HttpTransport()
    })

    this.infoClient = new hl.InfoClient({
      transport: new hl.HttpTransport()
    })

    // Derive wallet address from private key
    this.walletAddress = this.deriveAddress(privateKey)

    // Read post-only setting from environment
    this.enablePostOnly = process.env.ENABLE_POST_ONLY === 'true'
  }

  private deriveAddress(privateKey: string): string {
    // For simplicity, we'll use ethers to derive the address
    // In production, you might want to use the SDK's built-in method
    try {
      const wallet = new ethers.Wallet(privateKey)
      return wallet.address
    } catch (e) {
      throw new Error(`Failed to derive address from private key: ${e}`)
    }
  }

  /**
   * Generate unique client order ID (cloid)
   * Returns 128-bit hex string
   */
  private generateCloid(): string {
    this.cloidCounter++
    const timestamp = Date.now()
    const counter = this.cloidCounter
    // Create 128-bit hex string (32 characters)
    return `0x${timestamp.toString(16).padStart(16, '0')}${counter.toString(16).padStart(16, '0')}`
  }

  /**
   * Calculate appropriate price decimals based on price magnitude
   * This ensures prices are rounded to valid tick sizes
   */
  private getPriceDecimals(price: number): number {
    if (price >= 10000) return 1;      // BTC-like: $100k -> 1 decimal
    if (price >= 1000) return 2;       // BTC-like: $10k -> 2 decimals
    if (price >= 100) return 2;        // ETH-like: $100+ -> 2 decimals
    if (price >= 10) return 3;         // Mid-range: $10+ -> 3 decimals
    if (price >= 1) return 4;          // Low: $1+ -> 4 decimals
    if (price >= 0.1) return 5;        // Very low: $0.1+ -> 5 decimals
    return 6;                          // Ultra low: <$0.1 -> 6 decimals
  }

  /**
   * Round order size to szDecimals precision using floor rounding
   * Formula: Math.floor(size * 10^szDecimals) / 10^szDecimals
   * This prevents 422 errors from Hyperliquid API
   */
  private roundToSzDecimals(size: number, szDecimals: number): number {
    if (szDecimals === 0) {
      return Math.floor(size)
    }
    const multiplier = Math.pow(10, szDecimals)
    return Math.floor(size * multiplier) / multiplier
  }

  /**
   * Set leverage for a specific asset
   * @param pair - The trading pair (e.g., "BTC", "ETH")
   * @param leverage - Leverage value (1 for no leverage, 2 for 2x, etc.)
   */
  async setLeverage(pair: string, leverage: number = 1): Promise<void> {
    try {
      const assetIndex = this.assetMap.get(pair)
      if (assetIndex === undefined) {
        console.log(`Asset ${pair} not found in mapping, skipping leverage set`)
        return
      }

      await this.exchClient.updateLeverage({
        asset: assetIndex,
        isCross: true,  // Use cross margin (shares margin across positions)
        leverage: leverage
      })

      console.log(`âœ… Set ${pair} leverage to ${leverage}x`)
    } catch (error) {
      console.error(`Failed to set leverage for ${pair}: ${error}`)
      throw error
    }
  }

  async initialize(): Promise<void> {
    // Fetch asset mapping
    const [meta] = await this.api.getMetaAndAssetCtxs()

    meta.universe.forEach((market, index) => {
      this.assetMap.set(market.name, index)
      this.assetDecimals.set(market.name, market.szDecimals)
    })

    console.log(`LiveTrading initialized: ${this.assetMap.size} assets mapped`)

    // Initialize WebSocket for real-time data
    const enableWebSocket = process.env.ENABLE_WEBSOCKET === 'true'
    if (enableWebSocket && this.chaseConfig) {
      try {
        this.websocket = new HyperliquidWebSocket()
        await this.websocket.connect()
        console.log('âœ… WebSocket connected for real-time data')
      } catch (error) {
        console.error('âŒ Failed to connect WebSocket:', error)
      }
    }

    // Initialize Rate Limit Reserver
    const enableRateReserve = process.env.ENABLE_RATE_RESERVE === 'true'
    if (enableRateReserve) {
      this.rateLimitReserver = new RateLimitReserver(this.exchClient, true)
      console.log('âœ… Rate limit reservation enabled')
    }
  }

  /**
   * Subscribe to L2 book updates for trading pairs
   */
  subscribeToL2Books(pairs: string[]): void {
    if (!this.websocket || !this.websocket.isConnected()) {
      return
    }

    for (const pair of pairs) {
      // Check if already subscribed (avoid duplicate subscriptions)
      if (!this.l2BookCache.has(pair)) {
        this.websocket.subscribeL2Book(pair, (data: L2BookUpdate) => {
          // Cache the latest L2 book data
          this.l2BookCache.set(pair, data)
        })
        console.log(`ğŸ“Š Subscribed to L2 book: ${pair}`)
      }
    }
  }

  /**
   * Check rate limit usage and auto-reserve if needed
   */
  async checkAndReserveRateLimit(): Promise<void> {
    if (!this.rateLimitReserver) {
      return
    }

    // Estimate current rate limit usage based on recent order activity
    // Hyperliquid has a base limit of ~1200 requests/min
    const recentOrders = this.orderHistory.filter(
      o => Date.now() - o.timestamp < 60000
    )
    const currentUsage = recentOrders.length / 1200

    // Auto-reserve if usage is high (80% threshold)
    await this.rateLimitReserver.autoReserve(currentUsage, 0.8)
  }

  async placeOrder(
    pair: string,
    side: 'buy' | 'sell',
    price: number,
    sizeUsd: number,
    orderType: 'limit' | 'market' = 'limit',
    reduceOnly: boolean = false
  ): Promise<{ success: boolean; fillPrice?: number; fee?: number }> {
    try {
      // Get asset index and decimals
      const assetIndex = this.assetMap.get(pair)
      if (assetIndex === undefined) {
        throw new Error(`Asset ${pair} not found in mapping`)
      }

      // Get instrument specs for proper tick/lot alignment
      const specs = getInstrumentSpecs(pair)

      // Round price to valid tick size (institutional-grade rounding)
      let roundedPrice = roundToTick(price, specs.tickSize)

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TIER 2: Volatility Detection
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (this.chaseConfig) {
        // Get or create volatility tracker for this pair
        if (!this.volatilityTracker.has(pair)) {
          this.volatilityTracker.set(pair, new VolatilityTracker())
        }
        const volTracker = this.volatilityTracker.get(pair)!

        // Add current price to tracker
        volTracker.addPrice(price)

        // Check if volatile
        const rv = volTracker.getRealizedVolatility(this.chaseConfig.volatility.rvWindowMs)
        const isVolatile = rv > this.chaseConfig.volatility.sigmaFastThreshold

        if (isVolatile) {
          console.log(`âš¡ ${pair} volatile (Ïƒ=${rv.toFixed(4)}), widening spread by ${this.chaseConfig.volatility.spreadWidenTicks} ticks`)
          // Adjust offset based on volatility
          const offsetAdjustment = this.chaseConfig.volatility.spreadWidenTicks * specs.tickSize
          if (side === 'buy') {
            roundedPrice -= offsetAdjustment  // Buy lower when volatile
          } else {
            roundedPrice += offsetAdjustment  // Sell higher when volatile
          }
          roundedPrice = roundToTick(roundedPrice, specs.tickSize)
        }
      }

      // Convert USD size to coins
      let sizeInCoins = sizeUsd / roundedPrice

      // Infer szDecimals from price using centralized helper (unless valid map value exists)
      const inferredSizeDecimals = guessSzDecimals(roundedPrice)
      const mapValue = this.assetDecimals.get(pair)
      const sizeDecimals = (mapValue !== undefined && mapValue > 0) ? mapValue : inferredSizeDecimals

      // Exact quantization to szDecimals (floor)
      const decStep = Math.pow(10, -sizeDecimals)
      sizeInCoins = quantizeFloor(sizeInCoins, decStep)

      // Compute coin step (lot vs decimals)
      const coinStep = Math.max(specs.lotSize > 0 ? specs.lotSize : 0, decStep)

      // Enforce min coin based on lot grid (for tiny-price assets like PUMP)
      if (sizeInCoins + 1e-12 < coinStep) {
        sizeInCoins = quantizeCeil(coinStep, coinStep)
      }

      // Ensure price is exactly on tick (round to tick first, then fix decimals)
      roundedPrice = roundToTick(roundedPrice, specs.tickSize)
      const pxDec = priceDecimalsFromTick(specs.tickSize)
      roundedPrice = Number(roundedPrice.toFixed(pxDec))

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // AFTER-ROUNDING NOTIONAL CHECK: ceil one step if we fell below minNotional
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      let notionalAfter = sizeInCoins * roundedPrice
      if (notionalAfter + 1e-9 < specs.minNotional) {
        const old = sizeInCoins
        sizeInCoins = quantizeCeil(sizeInCoins + 1e-12, coinStep)
        notionalAfter = sizeInCoins * roundedPrice
        console.log(
          `[ADJUST] ${pair} ${side.toUpperCase()}: ` +
          `sz ${old.toFixed(sizeDecimals)}â†’${sizeInCoins.toFixed(sizeDecimals)} | ` +
          `notional ${(old*roundedPrice).toFixed(2)}â†’${notionalAfter.toFixed(2)}`
        )
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // FINAL QUANTIZATION & STRINGIFY (right before submit)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // (a) derive exact step decimals
      const stepDec = Math.max(0, -Math.floor(Math.log10(coinStep)))
      // pxDec already declared above

      // (b) Calculate integer number of steps (ensures exact divisibility)
      let numSizeSteps = Math.floor((sizeInCoins + 1e-12) / coinStep)

      // CRITICAL FIX for IEEE 754: When coinStep has decimals (0.1, 0.01),
      // some multiples cause float precision issues like 5128.2/0.1 = 51281.999...
      // Solution: Round to safe multiples (Ã—10 for 0.1, Ã—100 for 0.01)
      if (coinStep === 0.1) {
        if (numSizeSteps < 10) {
          numSizeSteps = 10
        } else {
          numSizeSteps = Math.floor(numSizeSteps / 10) * 10
        }
      } else if (coinStep === 0.01) {
        if (numSizeSteps < 100) {
          numSizeSteps = 100
        } else {
          numSizeSteps = Math.floor(numSizeSteps / 100) * 100
        }
      }

      // Side-aware tick snapping for price (avoid borderline rounding)
      const tickMultiplier = Math.pow(10, pxDec)
      const tickSizeInt = Math.round(specs.tickSize * tickMultiplier)
      let numPriceTicks: number
      if (side === 'buy') {
        numPriceTicks = Math.ceil((roundedPrice - 1e-12) / specs.tickSize)
      } else {
        numPriceTicks = Math.floor((roundedPrice + 1e-12) / specs.tickSize)
      }

      // (c) Build strings using PURE INTEGER arithmetic (zero floats)
      const stepMultiplier = Math.pow(10, stepDec)
      const coinStepInt = Math.round(coinStep * stepMultiplier)

      const sizeInt = numSizeSteps * coinStepInt
      const priceInt = numPriceTicks * tickSizeInt

      // Build decimal string manually: insert decimal point at correct position
      function intToDecimalString(intVal: number, decimals: number): string {
        if (decimals === 0) return intVal.toString()
        const str = intVal.toString().padStart(decimals + 1, '0')
        const decimalPos = str.length - decimals
        return str.slice(0, decimalPos) + '.' + str.slice(decimalPos)
      }

      const sizeStr = intToDecimalString(sizeInt, stepDec)
      const priceStr = intToDecimalString(priceInt, pxDec)

      // Update the actual values to match (for notional check below)
      sizeInCoins = Number(sizeStr)
      roundedPrice = Number(priceStr)

      // (d) preflight integer divisibility asserts using integer math (not float)
      // We already built sizeInt and priceInt as exact integer multiples above,
      // so these should always pass. Keep as sanity check.
      const sizeIntCheck = sizeInt % coinStepInt
      const priceIntCheck = priceInt % tickSizeInt

      if (sizeIntCheck !== 0) {
        console.warn(`Drop order: size not divisible (${pair}) sizeInt=${sizeInt} stepInt=${coinStepInt}`)
        return { success: false }
      }
      if (priceIntCheck !== 0) {
        console.warn(`Drop order: price not divisible (${pair}) priceInt=${priceInt} tickInt=${tickSizeInt}`)
        return { success: false }
      }

      // (e) DEBUG breadcrumb
      console.log(`ğŸ” DEBUG submit: pair=${pair} size=${sizeStr} step=${coinStep} price=${priceStr} tick=${specs.tickSize}`)

      // Safety check: ensure minimum notional
      const notionalValue = sizeInCoins * roundedPrice
      if (notionalValue < specs.minNotional) {
        console.warn(`âš ï¸  Order below min notional: $${notionalValue.toFixed(2)} < $${specs.minNotional}`)
        return { success: false }
      }

      // Sanity check: ensure no NaN or invalid values
      if (!Number.isFinite(roundedPrice) || !Number.isFinite(sizeInCoins)) {
        console.error(`âŒ Invalid order params: price=${roundedPrice}, size=${sizeInCoins}`)
        return { success: false }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TIER 2: Min Edge Check
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (this.chaseConfig && this.chaseConfig.minEdgeTicks > 0) {
        // Get current mid price from market
        const l2 = await this.infoClient.l2Book({ coin: pair })
        if (l2 && l2.levels && l2.levels[0] && l2.levels[0].length > 0 && l2.levels[1] && l2.levels[1].length > 0) {
          const bestAsk = parseFloat(l2.levels[0][0]?.px || '0')
          const bestBid = parseFloat(l2.levels[1][0]?.px || '0')
          const midPrice = (bestBid + bestAsk) / 2
          const edgeTicks = Math.abs(roundedPrice - midPrice) / specs.tickSize

          if (edgeTicks < this.chaseConfig.minEdgeTicks) {
            console.warn(`âš ï¸  ${pair} edge too small (${edgeTicks.toFixed(1)} < ${this.chaseConfig.minEdgeTicks} ticks), skipping order`)
            return { success: false }
          }
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TIER 2: Inventory Skewing
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (this.chaseConfig) {
        try {
          const userState = await this.infoClient.clearinghouseState({ user: this.walletAddress })
          if (userState && userState.assetPositions) {
            const position = userState.assetPositions.find((p: any) => p.position.coin === pair)
            if (position) {
              const szi = parseFloat(position.position.szi)
              const inventoryUsd = szi * roundedPrice
              const skewTicks = calculateInventorySkew(inventoryUsd, this.chaseConfig)

              if (skewTicks !== 0) {
                console.log(`ğŸ“Š ${pair} inventory skew: ${inventoryUsd.toFixed(0)} USD â†’ ${skewTicks} ticks`)
                const skewAdjustment = skewTicks * specs.tickSize
                // Skew pushes quotes away from current position
                // If long (positive inventory), widen sell quotes, tighten buy quotes
                if (side === 'buy') {
                  roundedPrice -= skewAdjustment  // Tighten buy when long
                } else {
                  roundedPrice += skewAdjustment  // Widen sell when long
                }
                roundedPrice = roundToTick(roundedPrice, specs.tickSize)
              }
            }
          }
        } catch (e) {
          // Ignore errors, continue without skew
        }
      }

      // DEBUG: Logging disabled for performance (uncomment if needed)
      // console.log(`[DEBUG] ${pair} Order:`)
      // console.log(`  sizeUsd: $${sizeUsd.toFixed(2)}`)
      // console.log(`  price: $${price}`)
      // console.log(`  sizeDecimals: ${sizeDecimals}`)
      // console.log(`  raw sizeInCoins: ${(sizeUsd / price).toFixed(8)}`)
      // console.log(`  rounded sizeInCoins: ${sizeInCoins}`)
      // console.log(`  assetIndex: ${assetIndex}`)

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TIER 3: Price Band Guards (prevent orders too far from last fill)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (this.chaseConfig && this.chaseConfig.priceBandTicks > 0) {
        const lastFill = this.lastFillPrice.get(pair)
        if (lastFill) {
          const priceDiffTicks = Math.abs(roundedPrice - lastFill) / specs.tickSize
          if (priceDiffTicks > this.chaseConfig.priceBandTicks) {
            console.warn(`âš ï¸  ${pair} price ${roundedPrice} too far from last fill ${lastFill} (${priceDiffTicks.toFixed(1)} > ${this.chaseConfig.priceBandTicks} ticks)`)
            return { success: false }
          }
        } else {
          // First order - set last fill to current price
          this.lastFillPrice.set(pair, roundedPrice)
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // TIER 3: Multi-level Ladder (TODO: requires batchModify integration)
      // Currently placing single order at best level
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Generate client order ID for tracking
      const cloid = this.generateCloid()

      // Build order request
      // Institutional chase mode: TIF support
      // Use short TIF (3-5s) for limit orders to reduce stale quotes
      const chaseConfig = this.chaseConfig || { tifSeconds: 3 }
      const tifSeconds = chaseConfig.tifSeconds || 0

      // Retry logic for ALO (post-only) rejections with auto-shade
      const maxRetries = this.chaseConfig?.retryOnPostOnlyReject || 1
      const autoShadeTicks = this.chaseConfig?.autoShadeOnRejectTicks || 1

      // Use stringified values for submission (exact decimals, avoid float conversion)
      let currentPriceStr = priceStr
      let currentSizeStr = sizeStr
      let attempt = 0
      let lastResult: any = null

      while (attempt <= maxRetries) {
        attempt++

        // Note: Hyperliquid doesn't have traditional "market" orders
        // For market-like execution, use limit orders with IOC (Immediate or Cancel)
        const orderRequest: any = {
          orders: [{
            a: assetIndex,
            b: side === 'buy',
            p: currentPriceStr,
            s: currentSizeStr,
            r: reduceOnly, // reduce-only flag for closing positions
            t: orderType === 'market'
              ? { limit: { tif: 'Ioc' } } // IOC for fast execution like market order
              : { limit: { tif: this.enablePostOnly ? 'Alo' : 'Gtc' } }, // Alo = post-only (maker-only), Gtc = can be taker
            c: cloid // Client order ID for tracking
          }],
          grouping: 'na'
        }

        // Add expiresAfter based on TIF setting
        // TIF=0 means GTC (5 min expiry), TIF>0 means short expiry (institutional mode)
        const expiresAfter = tifSeconds > 0
          ? Date.now() + (tifSeconds * 1000) // Short TIF (e.g., 3-5s)
          : Date.now() + (5 * 60 * 1000) // GTC fallback (5 min)

        // Place order with expiresAfter (pass as options object)
        console.log(`[SDK DEBUG] Placing order: pair=${pair} p=${orderRequest.orders[0].p} s=${orderRequest.orders[0].s}`)
        lastResult = await this.exchClient.order(orderRequest, { expiresAfter })
        // console.log(`[DEBUG] Order result:`, JSON.stringify(lastResult, null, 2))

        // Check for ALO rejection (post-only would cross)
        if (lastResult && lastResult.response && lastResult.response.data) {
          const statuses = lastResult.response.data.statuses
          if (statuses && statuses[0] && 'error' in statuses[0]) {
            const errorMsg = statuses[0].error || ''

            // ALO rejection - retry with shaded price
            if (errorMsg.includes('Alo') || errorMsg.includes('would cross')) {
              if (attempt <= maxRetries) {
                // Auto-shade using pure integer tick arithmetic (avoid float)
                const tickMultiplier = Math.pow(10, pxDec)
                const currentTicks = Math.round(Number(currentPriceStr) * tickMultiplier)
                const shadeTicks = side === 'buy' ? -autoShadeTicks : autoShadeTicks
                const shadedTicks = Math.max(0, currentTicks + shadeTicks)

                // Build string from integer ticks (reuse helper)
                function intToDecimalString(intVal: number, decimals: number): string {
                  if (decimals === 0) return intVal.toString()
                  const s = intVal.toString().padStart(decimals + 1, '0')
                  const p = s.length - decimals
                  return s.slice(0, p) + '.' + s.slice(p)
                }
                currentPriceStr = intToDecimalString(shadedTicks, pxDec)

                console.log(`âš ï¸  ALO reject - auto-shade attempt ${attempt}: ${side} @${currentPriceStr}`)
                continue // Retry with shaded price
              }
            }
          }
        }

        // Success or non-retryable error - break
        break
      }

      const result = lastResult

      // Check if order was successful
      if (result && result.status === 'ok') {
        let oidValue: string | undefined

        // Save cloid mapping if we got an oid back
        if (result.response && result.response.data && result.response.data.statuses) {
          const statuses = result.response.data.statuses
          if (statuses[0] && 'resting' in statuses[0]) {
            const oid = statuses[0].resting.oid
            oidValue = oid.toString()
            this.orderCloidMap.set(cloid, oidValue)
          }
        }

        // Record order in history
        this.recordOrder({
          cloid,
          oid: oidValue,
          pair,
          side,
          price,
          size: sizeInCoins,
          timestamp: Date.now(),
          status: 'placed',
          method: 'place'
        })

        // For limit orders, we won't know the fill price immediately
        // For market orders, we might get fill info in the response
        const feeBps = orderType === 'limit' ? this.makerFeeBps : this.takerFeeBps
        const fee = sizeUsd * feeBps / 10000

        return {
          success: true,
          fillPrice: price, // For limit orders, this is the requested price
          fee
        }
      } else {
        // Record rejected order
        this.recordOrder({
          cloid,
          pair,
          side,
          price,
          size: sizeInCoins,
          timestamp: Date.now(),
          status: 'rejected',
          method: 'place'
        })

        console.error(`âŒ Order failed:`, JSON.stringify(result, null, 2))
        return { success: false }
      }

    } catch (error) {
      console.error(`Error placing order [${pair} ${side}]: ${error}`)
      return { success: false }
    }
  }

  async cancelOrder(orderId: string): Promise<boolean> {
    try {
      // Cancel order using SDK
      const result = await this.exchClient.cancel({
        cancels: [{ a: 0, o: parseInt(orderId) }] // Simplified
      })
      return result && result.status === 'ok'
    } catch (error) {
      console.error(`Error canceling order: ${error}`)
      return false
    }
  }

  async getPosition(pair: string): Promise<{ size: number; entryPrice: number } | null> {
    try {
      // Get user state from Hyperliquid
      const userState = await this.infoClient.userState({ user: this.walletAddress })

      if (!userState || !userState.assetPositions) {
        return null
      }

      // Find position for this pair
      const assetIndex = this.assetMap.get(pair)
      if (assetIndex === undefined) {
        return null
      }

      const position = userState.assetPositions.find((p: any) => p.position.coin === pair)

      if (!position) {
        return null
      }

      return {
        size: parseFloat(position.position.szi),
        entryPrice: parseFloat(position.position.entryPx)
      }

    } catch (error) {
      console.error(`Error getting position: ${error}`)
      return null
    }
  }

  /**
   * Cancel all open orders - called on bot startup for clean slate
   */
  async cancelAllOrders(): Promise<void> {
    try {
      const orders = await this.infoClient.openOrders({ user: this.walletAddress })

      if (!orders || orders.length === 0) {
        console.log('No open orders to cancel')
        return
      }

      console.log(`Canceling ${orders.length} open orders...`)

      for (const order of orders) {
        const assetIndex = this.assetMap.get(order.coin)
        if (assetIndex === undefined) continue

        try {
          await this.exchClient.cancel({
            cancels: [{
              a: assetIndex,
              o: parseInt(order.oid)
            }]
          })
        } catch (e) {
          console.error(`Failed to cancel order ${order.oid}: ${e}`)
        }
      }

      console.log('All orders canceled')
    } catch (error) {
      console.error(`Error canceling all orders: ${error}`)
      throw error
    }
  }

  /**
   * Cancel all pending orders by invalidating the nonce
   *
   * This method uses a 'noop' transaction to invalidate the current nonce,
   * which effectively cancels all pending orders if the nonce transaction lands first.
   *
   * Benefits:
   * - Guaranteed cancellation if nonce tx lands first
   * - Saves rate limits compared to spam-canceling individual orders
   * - Single transaction instead of multiple cancel requests
   *
   * Use cases:
   * - Emergency cancel during high volatility
   * - Fallback when individual cancels fail
   * - Rate limit preservation
   */
  async cancelAllOrdersByNonce(): Promise<boolean> {
    try {
      console.log('ğŸ”„ Canceling all orders via nonce invalidation...')

      // Send a noop transaction to invalidate the nonce
      // This will cause all pending orders with the old nonce to be rejected
      const result = await this.exchClient.noop()

      if (result && result.status === 'ok') {
        console.log('âœ… Nonce invalidation successful - all pending orders canceled')
        return true
      } else {
        console.error('âŒ Nonce invalidation failed:', result)
        return false
      }
    } catch (error) {
      console.error('âŒ Error during nonce invalidation:', error)
      return false
    }
  }

  /**
   * Cancel all open orders for a specific trading pair
   * This prevents stacking of unfilled orders when price moves
   */
  async cancelPairOrders(pair: string): Promise<void> {
    try {
      const orders = await this.infoClient.openOrders({ user: this.walletAddress })

      if (!orders || orders.length === 0) return

      // Filter orders for this specific pair
      const pairOrders = orders.filter(order => order.coin === pair)
      if (pairOrders.length === 0) return

      for (const order of pairOrders) {
        const assetIndex = this.assetMap.get(order.coin)
        if (assetIndex === undefined) continue

        try {
          await this.exchClient.cancel({
            cancels: [{
              a: assetIndex,
              o: parseInt(order.oid)
            }]
          })
        } catch (e) {
          // Silently ignore cancel errors (order may have already filled)
        }
      }
    } catch (error) {
      // Silently ignore errors - we'll place new orders anyway
    }
  }

  /**
   * Get open orders for a specific trading pair
   */
  async getOpenOrders(pair: string): Promise<any[]> {
    try {
      const orders = await this.infoClient.openOrders({ user: this.walletAddress })
      if (!orders || orders.length === 0) return []

      // Filter orders for this specific pair
      return orders.filter(order => order.coin === pair)
    } catch (error) {
      return []
    }
  }

  /**
   * Batch modify orders - MORE EFFICIENT than cancel + place
   * Modifies existing orders to new prices in a single API call
   */
  async batchModifyOrders(pair: string, newBidPrice: number, newAskPrice: number, sizeUsd: number): Promise<boolean> {
    try {
      const orders = await this.getOpenOrders(pair)
      if (orders.length === 0) return false

      const assetIndex = this.assetMap.get(pair)
      if (assetIndex === undefined) return false

      const sizeDecimals = this.assetDecimals.get(pair) ?? 8
      const priceDecimals = this.getPriceDecimals(newBidPrice)

      const modifies: any[] = []

      for (const order of orders) {
        const isBuy = order.side === 'B'
        const newPrice = isBuy ? newBidPrice : newAskPrice
        let sizeInCoins = sizeUsd / newPrice

        // Round to szDecimals precision using floor rounding
        sizeInCoins = this.roundToSzDecimals(sizeInCoins, sizeDecimals)

        const roundedPrice = Number(newPrice.toFixed(priceDecimals))

        modifies.push({
          oid: parseInt(order.oid),
          order: {
            a: assetIndex,
            b: isBuy,
            p: roundedPrice.toString(),
            s: sizeInCoins.toString(),
            r: false,
            t: { limit: { tif: this.enablePostOnly ? 'Alo' : 'Gtc' } }
          }
        })
      }

      if (modifies.length === 0) return false

      // Add expiresAfter based on chase config (use staleQuoteKillMs for consistency)
      const chaseConfig = this.chaseConfig || { staleQuoteKillMs: 300000 }
      const expiresAfter = Date.now() + (chaseConfig.staleQuoteKillMs || 300000) // 5min default

      // Use customAction since SDK might not have batchModify typed
      const result = await (this.exchClient as any).batchModify({ modifies }, { expiresAfter })

      if (result && result.status === 'ok') {
        // Record cancelled orders (old orders being replaced)
        for (const order of orders) {
          const isBuy = order.side === 'B'
          const oldPrice = parseFloat(order.limitPx)
          const sizeInCoins = sizeUsd / oldPrice

          this.recordOrder({
            cloid: this.generateCloid(),
            oid: order.oid,
            pair,
            side: isBuy ? 'buy' : 'sell',
            price: oldPrice,
            size: sizeInCoins,
            timestamp: Date.now(),
            status: 'cancelled',
            method: 'batchModify'
          })
        }

        // Record modified orders (new orders)
        for (const order of orders) {
          const isBuy = order.side === 'B'
          const newPrice = isBuy ? newBidPrice : newAskPrice
          const sizeInCoins = sizeUsd / newPrice

          this.recordOrder({
            cloid: this.generateCloid(), // Generate new cloid for modified order
            oid: order.oid,
            pair,
            side: isBuy ? 'buy' : 'sell',
            price: newPrice,
            size: sizeInCoins,
            timestamp: Date.now(),
            status: 'modified',
            method: 'batchModify'
          })
        }
      }

      return result && result.status === 'ok'
    } catch (error) {
      console.error(`Error batch modifying orders: ${error}`)
      return false
    }
  }

  /**
   * Dead Man's Switch - Schedule automatic cancel of all orders
   * Safety feature: if bot crashes, orders will be auto-canceled
   */
  async enableDeadManSwitch(timeSeconds: number = 300): Promise<void> {
    try {
      const time = Date.now() + (timeSeconds * 1000)
      await this.exchClient.scheduleCancel({ time })
      this.deadManSwitchActive = true
      console.log(`âœ… Dead Man's Switch enabled (${timeSeconds}s)`)
    } catch (error) {
      console.error(`Failed to enable Dead Man's Switch: ${error}`)
    }
  }

  /**
   * Disable Dead Man's Switch
   */
  async disableDeadManSwitch(): Promise<void> {
    try {
      await this.exchClient.scheduleCancel({})
      this.deadManSwitchActive = false
      console.log(`âœ… Dead Man's Switch disabled`)
    } catch (error) {
      console.error(`Failed to disable Dead Man's Switch: ${error}`)
    }
  }

  /**
   * Reserve additional API request weight
   * Costs 0.0005 USDC per request weight
   */
  async reserveRequestWeight(weight: number): Promise<void> {
    try {
      // Use customAction since this is a direct exchange endpoint
      const result = await (this.exchClient as any).customAction({
        type: 'reserveRequestWeight',
        weight
      })
      if (result && result.status === 'ok') {
        console.log(`âœ… Reserved ${weight} request weight`)
      }
    } catch (error) {
      console.error(`Failed to reserve request weight: ${error}`)
    }
  }

  /**
   * Record order in history
   */
  recordOrder(entry: OrderHistoryEntry): void {
    this.orderHistory.push(entry)
    // Keep last 1000 orders only
    if (this.orderHistory.length > 1000) {
      this.orderHistory = this.orderHistory.slice(-1000)
    }
  }

  /**
   * Get order history (optionally filtered by time range)
   */
  getOrderHistory(sinceTimestamp?: number): OrderHistoryEntry[] {
    if (!sinceTimestamp) return this.orderHistory
    return this.orderHistory.filter(o => o.timestamp >= sinceTimestamp)
  }

  /**
   * Get summary statistics for order history
   */
  getOrderStats(sinceTimestamp?: number): {
    total: number
    placed: number
    modified: number
    cancelled: number
    filled: number
    rejected: number
    byPair: Record<string, number>
  } {
    const orders = this.getOrderHistory(sinceTimestamp)
    const stats = {
      total: orders.length,
      placed: orders.filter(o => o.status === 'placed').length,
      modified: orders.filter(o => o.status === 'modified').length,
      cancelled: orders.filter(o => o.status === 'cancelled').length,
      filled: orders.filter(o => o.status === 'filled').length,
      rejected: orders.filter(o => o.status === 'rejected').length,
      byPair: {} as Record<string, number>
    }

    // Count by pair
    for (const order of orders) {
      stats.byPair[order.pair] = (stats.byPair[order.pair] || 0) + 1
    }

    return stats
  }

  /**
   * Close all open positions - called on bot startup for clean slate
   */
  async closeAllPositions(): Promise<void> {
    try {
      const state = await this.infoClient.clearinghouseState({ user: this.walletAddress })

      if (!state.assetPositions || state.assetPositions.length === 0) {
        console.log('No open positions to close')
        return
      }

      console.log(`Closing ${state.assetPositions.length} positions...`)

      for (const assetPos of state.assetPositions) {
        const pos = assetPos.position
        const coin = pos.coin
        const size = parseFloat(pos.szi)

        if (size === 0) continue

        const assetIndex = this.assetMap.get(coin)
        if (assetIndex === undefined) continue

        const sizeDecimals = this.assetDecimals.get(coin) || 8
        const closeSize = Math.abs(size)

        try {
          // Get current market price
          const l2 = await this.infoClient.l2Book({ coin })
          const bestAsk = parseFloat(l2.levels[0]?.[0]?.px || '0')
          const bestBid = parseFloat(l2.levels[1]?.[0]?.px || '0')
          const midPrice = (bestAsk + bestBid) / 2

          // Close with market order (IOC with 5% slippage)
          let closePrice = size < 0
            ? midPrice * 1.05  // Buy to close short
            : midPrice * 0.95  // Sell to close long

          // Get tick size for proper quantization
          const specs = this.getAssetSpecs(coin)
          const tickSize = specs.tickSize
          const pxDec = Math.max(0, -Math.floor(Math.log10(tickSize)))

          // Quantize close price using integer arithmetic (avoid float precision issues)
          const numPriceTicks = Math.floor(closePrice / tickSize)
          const tickMultiplier = Math.pow(10, pxDec)
          const tickIntValue = Math.round(tickSize * tickMultiplier)
          const priceInt = numPriceTicks * tickIntValue
          const closePriceStr = (priceInt / tickMultiplier).toFixed(pxDec)

          // Round close size to szDecimals precision
          const roundedCloseSize = this.roundToSzDecimals(closeSize, sizeDecimals)

          await this.exchClient.order({
            orders: [{
              a: assetIndex,
              b: size < 0,  // buy if short, sell if long
              p: closePriceStr,
              s: roundedCloseSize.toString(),
              r: true,  // reduce-only
              t: { limit: { tif: 'Ioc' } }
            }],
            grouping: 'na'
          })

          console.log(`Closed ${coin}: ${size > 0 ? 'LONG' : 'SHORT'} ${closeSize}`)
        } catch (e) {
          console.error(`Failed to close ${coin} position: ${e}`)
        }
      }

      console.log('All positions closed')
    } catch (error) {
      console.error(`Error closing all positions: ${error}`)
      throw error
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HYPERLIQUID MM BOT - Main bot class
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HyperliquidMMBot {
  private api: HyperliquidAPI
  private rotation: VolatilityRotation
  private supervisor: Supervisor
  private stateManager: StateManager
  private trading: TradingInterface
  private notifier: ConsoleNotifier
  private nansen: ReturnType<typeof getNansenProAPI>
  private orderReporter: OrderReporter
  private chaseConfig: ChaseConfig | null = null
  private gridManager: GridManager | null = null
  private legacyUnwinder: LegacyUnwinder

  private intervalSec: number
  private baseOrderUsd: number
  private makerSpreadBps: number
  private rotationIntervalSec: number
  private maxDailyLossUsd: number
  private lastRotationTime: number = 0
  private lastActivePairsSource: string | null = null

  // Taker order strategy (unlocks API rate limits)
  private enableTakerOrders: boolean
  private takerOrderIntervalMs: number
  private takerOrderSizeUsd: number
  private lastTakerOrderTime: number = 0

  // Copy-trading configuration
  private enableCopyTrading: boolean
  private copyTradingMinConfidence: number
  private copyTradingMinTraders: number
  private lastCopyTradingCheck: number = 0

  private tuning = {
    orderUsdFactor: 1.0,
    maxConcurrent: 1,
    backoffMs: 0,
    makerSpreadFactor: 1.0
  }

  private isDryRun: boolean

  constructor() {
    this.api = new HyperliquidAPI()
    this.rotation = new VolatilityRotation({
      minVolatility: Number(process.env.MIN_VOLATILITY_PCT || 2.0),
      rotationThreshold: 1.5
    })
    this.stateManager = new StateManager()
    this.notifier = new ConsoleNotifier()
    this.nansen = getNansenProAPI()
    this.orderReporter = new OrderReporter(this.notifier)

    // Initialize chase config (Institutional preset - HFT mode)
    const enableChaseMode = process.env.CHASE_MODE_ENABLED === 'true'
    if (enableChaseMode) {
      this.chaseConfig = INSTITUTIONAL_PRESET
      console.log('ğŸ Chase mode enabled: INSTITUTIONAL_PRESET')
    }

    // Initialize GridManager (Institutional multi-layer quoting)
    const enableMultiLayer = process.env.ENABLE_MULTI_LAYER === 'true'
    if (enableMultiLayer) {
      this.gridManager = new GridManager()
      console.log('ğŸ›ï¸  Multi-layer grid enabled:', this.gridManager.getSummary())
    }

    // Initialize Legacy Unwinder
    this.legacyUnwinder = createLegacyUnwinderFromEnv()
    console.log('ğŸ“¦ Legacy unwinding enabled: mode=' + (process.env.LEGACY_UNWIND_MODE || 'passive'))

    // Configuration from env
    this.intervalSec = Number(process.env.MM_INTERVAL_SEC || 15)
    this.baseOrderUsd = Number(process.env.BASE_ORDER_USD || 150)
    this.makerSpreadBps = Number(process.env.MAKER_SPREAD_BPS || 40)
    this.rotationIntervalSec = Number(process.env.ROTATION_INTERVAL_SEC || 14400) // 4 hours
    this.maxDailyLossUsd = Number(process.env.MAX_DAILY_LOSS_USD || 400)
    this.isDryRun = process.env.DRY_RUN === 'true'

    // Taker order configuration
    this.enableTakerOrders = process.env.ENABLE_TAKER_ORDERS === 'true'
    this.takerOrderIntervalMs = Number(process.env.TAKER_ORDER_INTERVAL_MIN || 60) * 60 * 1000
    this.takerOrderSizeUsd = Number(process.env.TAKER_ORDER_SIZE_USD || 100)

    // Copy-trading configuration
    this.enableCopyTrading = process.env.COPY_TRADING_ENABLED === 'true'
    this.copyTradingMinConfidence = Number(process.env.COPY_TRADING_MIN_CONFIDENCE || 60)
    this.copyTradingMinTraders = Number(process.env.COPY_TRADING_MIN_TRADERS || 3)

    // Initialize trading interface based on mode
    if (this.isDryRun) {
      this.trading = new PaperTrading()
      this.notifier.info('ğŸ“„ PAPER TRADING MODE - No real money at risk')
    } else {
      const privateKey = process.env.PRIVATE_KEY
      if (!privateKey) {
        throw new Error('âŒ PRIVATE_KEY required for live trading! Set DRY_RUN=true for paper trading.')
      }
      this.trading = new LiveTrading(privateKey, this.api, this.chaseConfig)
      this.notifier.info('ğŸ’° LIVE TRADING MODE - REAL MONEY AT RISK!')
    }

    // Initialize supervisor
    const hooks: SupervisorHooks = {
      getExecStats: async () => this.stateManager.getExecStats(),
      getBalances: async () => ({ eth: 1.0, usdc: 20000 }), // Mock for now
      getStaleSec: async () => 0,
      pingVenue: async () => {
        try {
          await this.api.getMetaAndAssetCtxs()
          return true
        } catch {
          return false
        }
      },
      pingRpc: async () => true, // Mock
      applyTuning: async (t) => {
        // TUNING DISABLED: Always use 100% order size regardless of success rate
        this.tuning = {
          ...t,
          orderUsdFactor: 1.0  // Force 100% - ignoring auto-tuning adjustments
        }
      },
      setIntervalSec: (sec) => {
        this.intervalSec = sec
      },
      onKillSwitch: async () => {
        this.notifier.error('ğŸš¨ KILL SWITCH ACTIVATED - Stopping bot')
        process.exit(1)
      }
    }

    this.supervisor = new Supervisor({
      rpcUrls: ['https://api.hyperliquid.xyz'],
      venueProbes: [
        { name: 'Hyperliquid', url: 'https://api.hyperliquid.xyz/info', method: 'POST' }
      ],
      hooks,
      baseIntervalSec: this.intervalSec,
      maxIntervalSec: 45,
      notifier: this.notifier
    })

    this.notifier.info(`ğŸ¤– Hyperliquid MM Bot initialized`)
    this.notifier.info(`   Mode: ${this.isDryRun ? 'PAPER TRADING' : 'LIVE'}`)
    this.notifier.info(`   Base interval: ${this.intervalSec}s`)
    this.notifier.info(`   Base order size: $${this.baseOrderUsd}`)
    this.notifier.info(`   Maker spread: ${this.makerSpreadBps} bps`)
    this.notifier.info(`   Rotation interval: ${this.rotationIntervalSec / 3600}h`)
    if (this.enableTakerOrders) {
      this.notifier.info(`   âš¡ Taker orders: ENABLED ($${this.takerOrderSizeUsd} every ${this.takerOrderIntervalMs / 60000}min)`)
    }
    if (this.nansen.isEnabled()) {
      this.notifier.info(`   ğŸ”¥ Nansen Pro: ENABLED (Copy-trading + Smart Money tracking)`)
      if (this.enableCopyTrading) {
        this.notifier.info(`   ğŸ“Š Copy-trading: ${this.copyTradingMinConfidence}% confidence, ${this.copyTradingMinTraders}+ traders`)
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Initialization
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async initialize() {
    this.notifier.info('ğŸš€ Initializing bot...')

    // Initialize live trading if not in dry run mode
    if (!this.isDryRun && this.trading instanceof LiveTrading) {
      await (this.trading as LiveTrading).initialize()
      this.notifier.info('âœ… Live trading initialized')

      // AUTOMATIC CLEANUP ON STARTUP (optional via SKIP_STARTUP_CLEANUP env var)
      const skipCleanup = process.env.SKIP_STARTUP_CLEANUP === 'true'

      if (skipCleanup) {
        this.notifier.info('â­ï¸  Skipping startup cleanup - keeping existing positions')
      } else {
        this.notifier.info('ğŸ§¹ Cleaning up: canceling all open orders and closing positions...')
        try {
          await (this.trading as LiveTrading).cancelAllOrders()
          this.notifier.info('   âœ… All orders canceled')

          await (this.trading as LiveTrading).closeAllPositions()
          this.notifier.info('   âœ… All positions closed')

          this.notifier.info('âœ… Cleanup complete - starting with clean slate')
        } catch (error) {
          this.notifier.error(`âŒ Cleanup failed: ${error}`)
          throw new Error('Failed to cleanup on startup')
        }
      }
    } else {
      this.notifier.info('âœ… Paper trading ready')
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Main Loop
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async mainLoop() {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INVENTORY SYNC START â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    try {
      const positions = await this.api.getPositions();
      if (Array.isArray(positions)) {
        this.state.positions = {};
        for (const p of positions) {
          const side = (p.side || "flat").toLowerCase();
          const entryPx = parseFloat(p.entryPx || 0);
          const markPx = parseFloat(p.markPx || 0);
          const sizeUsd = parseFloat(p.sizeUsd || 0);
          const size = markPx > 0 ? sizeUsd / markPx : 0;
          this.state.positions[p.coin] = {
            size, entryPrice: entryPx, side
          };
        }
        console.log("ğŸ“Š Synced positions:", Object.keys(this.state.positions));
      }
    } catch (e) {
      console.warn("âš ï¸ Position sync failed:", e.message);
    }
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INVENTORY SYNC END â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      try {
        // Check kill switch
        if (await killSwitchActive()) {
          this.notifier.error('âŒ Kill switch active - bot stopped')
          break
        }

        // Reset daily PnL if new day
        this.stateManager.resetDailyPnl()

        // âš¡ SYNC PnL FROM HYPERLIQUID (SOURCE OF TRUTH)
        if (this.trading instanceof LiveTrading) {
          const syncResult = await this.stateManager.syncPnLFromHyperliquid(
            (this.trading as any).infoClient,
            (this.trading as any).walletAddress
          )
          if (syncResult.newFills > 0) {
            this.notifier.info(`âœ… Synced ${syncResult.newFills} new fills | PnL Î”: $${syncResult.pnlDelta.toFixed(2)}`)
          }
        }

        // Check daily loss limit
        const state = this.stateManager.getState()
        if (state.dailyPnl < -this.maxDailyLossUsd) {
          this.notifier.error(`âŒ Daily loss limit reached: $${state.dailyPnl.toFixed(2)}`)
          break
        }

        // Rotate pairs if needed
        await this.rotateIfNeeded()

        // Execute market making
        // Get active pairs from rotation (top 3 by volatility)
        // Priority: 1) active_pairs.json  2) ACTIVE_PAIRS env  3) rotation
        let activePairs: string[] = []
        
        // Try loading from active_pairs.json first
        const loadResult = loadActivePairs({ staleSec: 900, maxCount: 10 })
        if (loadResult.ok && loadResult.pairs.length > 0) {
          activePairs = loadResult.pairs
          if (!this.lastActivePairsSource || this.lastActivePairsSource !== "file") {
            this.notifier.info(`ğŸ“‹ Using pairs from active_pairs.json: ${activePairs.join(", ")}`)
            this.lastActivePairsSource = "file"
          }
        } else if (process.env.ACTIVE_PAIRS && process.env.ACTIVE_PAIRS.trim()) {
          activePairs = process.env.ACTIVE_PAIRS.split(",").map(p => p.trim().toUpperCase()).filter(Boolean)
          if (!this.lastActivePairsSource || this.lastActivePairsSource !== "env") {
            this.notifier.info(`ğŸ”§ Using pairs from ACTIVE_PAIRS env: ${activePairs.join(", ")}`)
            this.lastActivePairsSource = "env"
          }
        } else {
          activePairs = this.rotation.getCurrentPairs()
          if (!this.lastActivePairsSource || this.lastActivePairsSource !== "rotation") {
            this.notifier.info(`ğŸ”„ Using pairs from rotation: ${activePairs.join(", ")}`)
            this.lastActivePairsSource = "rotation"
          }
        }

        // Trade ONLY configured pairs (no legacy position auto-trading)
        const allPairsToTrade = activePairs

        if (allPairsToTrade.length > 0) {
          // Subscribe to L2 books for real-time data (WebSocket)
          if (this.trading instanceof LiveTrading) {
            this.trading.subscribeToL2Books(allPairsToTrade)
          }

          // Execute MM for ALL pairs (active + legacy)
          await this.executeMM(allPairsToTrade, activePairs)

          // Check and reserve rate limit if needed
          if (this.trading instanceof LiveTrading) {
            await this.trading.checkAndReserveRateLimit()
          }
        } else {
          this.notifier.warn('âš ï¸  No pairs selected yet, waiting for rotation...')
        }

        // Execute taker order if enabled (unlocks rate limits)
        if (this.enableTakerOrders && !this.isDryRun) {
          await this.executeTakerOrder()
        }

        // Supervisor tick
        const supervisorResult = await this.supervisor.tick()

        // Check if it's time to send order report
        if (this.orderReporter.shouldSendReport() && this.trading instanceof LiveTrading) {
          const sinceTime = Date.now() - (4 * 60 * 60 * 1000) // Last 4 hours
          const orders = this.trading.getOrderHistory(sinceTime)
          const stats = this.trading.getOrderStats(sinceTime)
          await this.orderReporter.sendReport(orders, stats)
        }

        // Log status
        this.logStatus(supervisorResult)

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SANITY ASSERTIONS - Cheap runtime checks on every iteration
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const currentState = this.stateManager.getState()
        if (!Number.isFinite(currentState.dailyPnl)) {
          this.notifier.warn('âš ï¸  NaN dailyPnl detected')
        }

        // Sleep
        await this.sleep(this.intervalSec * 1000)

      } catch (error) {
        this.notifier.error(`Error in main loop: ${error}`)
        this.stateManager.recordExecution(false)
        await this.sleep(5000)
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Volatility Rotation
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async rotateIfNeeded() {
    const now = Date.now()

    if (now - this.lastRotationTime < this.rotationIntervalSec * 1000) {
      return // Not time yet
    }

    this.notifier.info('ğŸ”„ Checking volatility rotation...')

    // Check copy-trading signals if enabled
    let copyTradingSignals: CopyTradingSignal[] = []
    if (this.enableCopyTrading && this.nansen.isEnabled()) {
      try {
        copyTradingSignals = await this.nansen.getCopyTradingSignals(
          this.copyTradingMinConfidence,
          this.copyTradingMinTraders
        )

        if (copyTradingSignals.length > 0) {
          this.notifier.info(`ğŸ”¥ Found ${copyTradingSignals.length} copy-trading signals`)
          for (const sig of copyTradingSignals.slice(0, 3)) {
            this.notifier.info(`   ${sig.side === 'LONG' ? 'ğŸŸ¢' : 'ğŸ”´'} ${sig.token_symbol}: ${sig.confidence}% confidence (${sig.trader_count} traders)`)
          }
          // Store signals for use during execution
          this.storeCopyTradingSignals(copyTradingSignals)
        }
      } catch (error) {
        this.notifier.warn(`Copy-trading signals failed: ${error}`)
      }
    }

    try {
      const result = await this.rotation.rotate()

      if (result.rotated) {
        this.notifier.info(`âœ… Rotated to: ${result.newPairs.join(', ')}`)
        this.notifier.info(`   Reason: ${result.reason}`)

        // Log top 3 scores
        result.scores.forEach((s, i) => {
          this.notifier.info(`   ${i + 1}. ${s.pair}: score=${s.score.toFixed(2)}, vol=${s.volatility24h.toFixed(2)}%`)
        })

        // Set leverage for new pairs (LIVE mode only)
        if (!this.isDryRun && this.trading instanceof LiveTrading) {
          const targetLeverage = Number(process.env.LEVERAGE || 1)
          this.notifier.info(`ğŸ”§ Setting ${targetLeverage}x leverage for new pairs...`)

          for (const pair of result.newPairs) {
            try {
              await (this.trading as LiveTrading).setLeverage(pair, targetLeverage)
            } catch (error) {
              this.notifier.warn(`   Failed to set leverage for ${pair}: ${error}`)
            }
          }
        }

        // Close positions in pairs we're rotating out of
        await this.closeOldPositions(result.newPairs)
      } else {
        this.notifier.info(`âœ“ Current pairs still optimal: ${result.newPairs.join(', ')}`)
      }

      this.lastRotationTime = now

    } catch (error) {
      this.notifier.error(`Error in rotation: ${error}`)
    }
  }

  async closeOldPositions(newPairs: string[]) {
    const state = this.stateManager.getState()
    const positionsToClose = Object.keys(state.positions).filter(pair => !newPairs.includes(pair))

    const minLossToClose = parseFloat(process.env.MIN_LOSS_TO_CLOSE_USD || '-5') // Only close if loss < $5

    for (const pair of positionsToClose) {
      const pos = state.positions[pair]

      // Get current market price to calculate potential PnL
      try {
        const l2 = await this.infoClient.l2Book({ coin: pair })
        const bestBid = parseFloat(l2.levels[1]?.[0]?.px || '0')
        const bestAsk = parseFloat(l2.levels[0]?.[0]?.px || '0')
        const currentPrice = pos.side === 'long' ? bestBid : bestAsk

        // Calculate expected PnL
        const expectedPnl = pos.side === 'long'
          ? (currentPrice - pos.entryPrice) * pos.size
          : (pos.entryPrice - currentPrice) * pos.size

        // Only close if profitable OR small acceptable loss
        // minLossToClose = -50 (negative), expectedPnl = -0.14 (small loss)
        // Skip if loss exceeds threshold: -0.14 > -50 means loss is SMALLER than threshold, so close it
        // Skip if loss exceeds threshold: -60 > -50 is FALSE, means loss EXCEEDS threshold, so skip
        if (expectedPnl < minLossToClose) {
          this.notifier.warn(`   â¸ï¸  Skipping close for ${pair}: Expected loss $${expectedPnl.toFixed(2)} exceeds threshold $${minLossToClose} - will retry next rotation`)
          continue
        }

        this.notifier.info(`   Closing ${pair} position: ${pos.side} ${pos.size} (Expected PnL: $${expectedPnl.toFixed(2)})`)

        // Place reduce-only order to close position
        const closeResult = await this.trading.placeOrder(
          pair,
          pos.side === 'long' ? 'sell' : 'buy',
          currentPrice, // Use current market price
          pos.size,
          'market', // Will use IOC for fast execution
          true // reduce-only flag
        )

        if (closeResult.success && closeResult.fillPrice) {
          const actualPnl = pos.side === 'long'
            ? (closeResult.fillPrice - pos.entryPrice) * pos.size
            : (pos.entryPrice - closeResult.fillPrice) * pos.size

          this.stateManager.recordTrade(pair, 'close', closeResult.fillPrice, pos.size, actualPnl)
          this.stateManager.updatePosition(pair, 0, 0, 'long')
          this.notifier.info(`   âœ“ Closed ${pair}: PnL $${actualPnl.toFixed(2)}`)
        }
      } catch (error) {
        this.notifier.error(`   Failed to close ${pair}: ${error}`)
      }
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Legacy Position Management
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Get all pairs with open positions from the account
   */
  async getAllPositionPairs(): Promise<string[]> {
    try {
      // Defensive check: ensure API clients are initialized
      if (!this.api || !this.api.infoClient || typeof this.api.infoClient.clearinghouseState !== 'function') {
        this.notifier.warn(`API infoClient not initialized`)
        return []
      }

      const userState = await this.api.infoClient.clearinghouseState({ user: this.walletAddress })

      if (!userState || !userState.assetPositions) {
        return []
      }

      // Extract pairs with non-zero position sizes
      const positionPairs = userState.assetPositions
        .filter((pos: any) => {
          const size = Math.abs(parseFloat(pos.position?.szi || '0'))
          return size > 0
        })
        .map((pos: any) => pos.position?.coin || '')
        .filter((pair: string) => pair !== '')

      return positionPairs
    } catch (error) {
      this.notifier.warn(`Failed to get position pairs: ${error}`)
      return []
    }
  }

  /**
   * Check if legacy positions are profitable and close them
   */
  async checkAndCloseProfitableLegacyPositions(legacyPairs: string[], assetCtxs: any[]) {
    const minProfitPct = parseFloat(process.env.LEGACY_PROFIT_THRESHOLD_PCT || '0.5') // Default: 0.5%

    for (const pair of legacyPairs) {
      try {
        // Defensive check: ensure API clients are initialized
        if (!this.api || !this.api.infoClient || typeof this.api.infoClient.clearinghouseState !== 'function') {
          this.notifier.warn(`API infoClient not initialized for legacy position check`)
          continue
        }

        // Get position info from account
        const userState = await this.api.infoClient.clearinghouseState({ user: this.walletAddress })
        if (!userState?.assetPositions) continue

        const positionData = userState.assetPositions.find((p: any) => p.position?.coin === pair)
        if (!positionData?.position) continue

        const szi = parseFloat(positionData.position.szi)
        if (Math.abs(szi) === 0) continue

        const entryPx = parseFloat(positionData.position.entryPx || '0')
        const unrealizedPnl = parseFloat(positionData.position.unrealizedPnl || '0')

        // Get current market price
        const pairData = assetCtxs.find(ctx => ctx.coin === pair)
        if (!pairData) continue

        const midPrice = parseFloat(pairData.midPx || '0')
        if (midPrice === 0) continue

        // Calculate profit percentage
        const positionSize = Math.abs(szi)
        const positionValueUsd = positionSize * entryPx
        const profitPct = (unrealizedPnl / positionValueUsd) * 100

        this.notifier.info(`ğŸ“Š ${pair} Legacy PnL: $${unrealizedPnl.toFixed(2)} (${profitPct.toFixed(2)}%)`)

        // Close if profitable enough
        if (profitPct >= minProfitPct) {
          this.notifier.info(`ğŸ’° Closing profitable legacy position: ${pair} at ${profitPct.toFixed(2)}% profit`)

          // Determine side for closing (opposite of current position)
          const side = szi > 0 ? 'sell' : 'buy'

          // Place reduce-only order to close position
          const closeResult = await this.trading.placeOrder(
            pair,
            side,
            midPrice,
            positionSize,
            'market', // Use market order for fast execution
            true // reduce-only flag
          )

          if (closeResult.success && closeResult.fillPrice) {
            const actualPnl = parseFloat(positionData.position.unrealizedPnl || '0')
            this.stateManager.recordTrade(pair, 'close', closeResult.fillPrice, positionSize, actualPnl)
            this.notifier.info(`âœ… Closed ${pair} legacy position: PnL $${actualPnl.toFixed(2)}`)
          }
        }
      } catch (error) {
        this.notifier.warn(`Failed to check/close legacy position for ${pair}: ${error}`)
      }
    }
  }

  /**
   * Store copy-trading signals for reference during execution
   * (Can be used to adjust order sizing or prioritize certain pairs)
   */
  private copyTradingSignalMap: Map<string, CopyTradingSignal> = new Map()

  private storeCopyTradingSignals(signals: CopyTradingSignal[]) {
    this.copyTradingSignalMap.clear()
    for (const sig of signals) {
      this.copyTradingSignalMap.set(sig.token_symbol, sig)
    }
  }

  private getCopyTradingSignal(pair: string): CopyTradingSignal | undefined {
    return this.copyTradingSignalMap.get(pair)
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Market Making Execution
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async executeMM(pairs: string[], activePairs: string[] = []) {
    // âš¡ OPTIMIZED: Fetch market data ONCE for all pairs (major latency improvement!)
    const [meta, assetCtxs] = await this.api.getMetaAndAssetCtxs()

    // Identify legacy pairs (positions not in top 3)
    const legacyPairs = pairs.filter(p => !activePairs.includes(p))

    if (legacyPairs.length > 0) {
      this.notifier.info(`ğŸ“¦ Legacy positions: ${legacyPairs.join(', ')} - continuing market-making`)
    }

    // âš¡ OPTIMIZED: Execute all pairs in parallel with shared market data
    // Both active and legacy pairs get full market-making (limit orders)
    await Promise.all(
      pairs.map(async (pair) => {
        try {
          await this.executePairMM(pair, assetCtxs)
        } catch (error) {
          this.notifier.error(`Error executing MM for ${pair}: ${error}`)
          this.stateManager.recordExecution(false)
        }
      })
    )
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // INSTITUTIONAL MULTI-LAYER MARKET MAKING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Compute per-asset clip that guarantees â‰¥ min notional after rounding
   *
   * Returns {clipUsd, coinStep, coinsRounded, usdRounded}
   *
   * Logic:
   * 1. coinStep = max(lotSize, 10^-guessedSzDecimals)
   * 2. Round *up* (Math.ceil) so we never go below minNotional
   * 3. Return both coin-based and USD-based rounded values
   */
  private computePerAssetClip(
    pair: string,
    midPx: number,
    globalClipUsd: number,
    minNotionalUsd: number,
    specs: { lotSize?: number },
    guessedSzDecimals: number
  ): { clipUsd: number; coinStep: number; coinsRounded: number; usdRounded: number } {
    // Use centralized helper for coin step
    const coinStep = coinStepFrom(specs, guessedSzDecimals)

    // Start with the larger of globalClip or minNotional
    const targetUsd = Math.max(globalClipUsd, minNotionalUsd)

    // Convert to coins
    const rawCoins = targetUsd / midPx

    // Round UP to next coin step (ceiling) using exact quantization
    const coinsRounded = quantizeCeil(rawCoins, coinStep)

    // Recompute USD value after rounding
    const usdRounded = coinsRounded * midPx

    // Final clip is the rounded-up USD value (plus small buffer for safety)
    const clipUsd = Math.max(globalClipUsd, Math.ceil(usdRounded + 0.5))

    console.log(
      `[DEBUG CLIP] ${pair}: ` +
      `px=${midPx.toFixed(2)}, szDec=${guessedSzDecimals}, coinStep=${coinStep}, ` +
      `raw=${rawCoins.toFixed(4)}coin, ceil=${coinsRounded}coin, ` +
      `clipUsd=${clipUsd}`
    )

    return { clipUsd, coinStep, coinsRounded, usdRounded }
  }

  async executeMultiLayerMM(pair: string, assetCtxs?: any[]) {
    const startTime = Date.now()

    // Only trade specific symbol in test mode - if empty, enable for all pairs
    const testSymbol = process.env.MULTI_LAYER_TEST_SYMBOL
    if (testSymbol && pair !== testSymbol) {
      // Use regular MM for non-test pairs without disabling gridManager
      return await this.executeRegularMM(pair, assetCtxs)
    }

    // Get current market data
    if (!assetCtxs) {
      const [meta, ctxs] = await this.api.getMetaAndAssetCtxs()
      assetCtxs = ctxs
    }
    const pairData = assetCtxs.find(ctx => ctx.coin === pair)

    if (!pairData) {
      this.notifier.warn(`âš ï¸  No data for ${pair}`)
      return
    }

    const midPrice = Number(pairData.midPx || 0)
    if (midPrice === 0) {
      this.notifier.warn(`âš ï¸  Invalid mid price for ${pair}`)
      return
    }

    // Get position and calculate inventory skew
    const state = this.stateManager.getState()
    const position = state.positions[pair]

    // Calculate inventory skew as percentage of capital
    // position.size is in coins, need to convert to USD value
    const capitalPerPair = this.baseOrderUsd // Use BASE_ORDER_USD from config
    let inventorySkew = 0
    if (position) {
      const positionValueUsd = position.size * midPrice
      inventorySkew = positionValueUsd / capitalPerPair // -1 to 1 range (negative = short, positive = long)
    }

    // Generate grid orders
    let gridOrders = this.gridManager!.generateGridOrders(
      pair,
      midPrice,
      capitalPerPair,
      0.001,
      inventorySkew
    )

    const MIN_NOTIONAL = Number(process.env.MIN_NOTIONAL_USD ?? 10)
    const GLOBAL_CLIP = Number(process.env.CLIP_USD ?? 15)

    // Get instrument specs for proper rounding
    const specs = getInstrumentSpecs(pair)
    // Infer szDecimals from price using centralized helper
    const sizeDecimals = guessSzDecimals(midPrice)

    // Compute per-asset clip with round-up logic to guarantee notional floors
    const { clipUsd, coinStep, coinsRounded, usdRounded } = this.computePerAssetClip(
      pair,
      midPrice,
      GLOBAL_CLIP,
      MIN_NOTIONAL,
      specs,
      sizeDecimals
    )

    // Re-bucket children so each child is â‰¥ GLOBAL_CLIP and â‰¥ MIN_NOTIONAL
    // while keeping the total USD roughly the same.
    // NOTE: We use GLOBAL_CLIP here (not clipUsd) because clipUsd is the post-rounding
    // target used for verification. The rebucketing just needs to meet the min notional floor.
    const totalBefore = gridOrders.reduce((a, o) => a + (o.sizeUsd || 0), 0)
    gridOrders = normalizeChildNotionals(
      gridOrders,
      { targetUsd: GLOBAL_CLIP, minUsd: MIN_NOTIONAL }
    )
    const totalAfter = gridOrders.reduce((a, o) => a + (o.sizeUsd || 0), 0)

    this.notifier.info(
      `ğŸ›ï¸  ${pair} Multi-Layer: ${gridOrders.length} orders | Mid: $${midPrice.toFixed(4)} | ` +
      `Skew: ${(inventorySkew * 100).toFixed(1)}% | Rebucket: ${totalBefore.toFixed(2)}â†’${totalAfter.toFixed(2)} USD | ` +
      `childâ‰¥${clipUsd}`
    )

    // Cancel existing orders
    if (this.trading instanceof LiveTrading) {
      const existingOrders = await this.trading.getOpenOrders(pair)
      if (existingOrders.length > 0) {
        await this.trading.cancelPairOrders(pair)
      }
    }

    // Place grid orders
    for (const gridOrder of gridOrders) {
      const side = gridOrder.side === 'bid' ? 'buy' : 'sell'

      // Drop anything below min notional as a final safety
      if (gridOrder.sizeUsd + 1e-9 < MIN_NOTIONAL) {
        this.notifier.warn(`   drop < minNotional: $${gridOrder.sizeUsd.toFixed(2)} < $${MIN_NOTIONAL}`)
        continue
      }

      this.notifier.info(`   L${gridOrder.layer} ${side.toUpperCase()}: $${gridOrder.price.toFixed(4)} Ã— ${gridOrder.units.toFixed(2)} ($${gridOrder.sizeUsd.toFixed(0)})`)

      await this.trading.placeOrder(
        pair,
        side,
        gridOrder.price,
        gridOrder.sizeUsd,  // placeOrder expects USD, it converts to units internally
        'limit'
      )
    }

    this.stateManager.recordExecution(true, Date.now() - startTime)
  }

  async executePairMM(pair: string, assetCtxs?: any[]) {
    // Route to multi-layer grid if enabled
    if (this.gridManager) {
      return await this.executeMultiLayerMM(pair, assetCtxs)
    }

    // Fallback to regular MM
    return await this.executeRegularMM(pair, assetCtxs)
  }

  async executeRegularMM(pair: string, assetCtxs?: any[]) {
    const startTime = Date.now()

    // Get current market data (use cached if provided)
    if (!assetCtxs) {
      const [meta, ctxs] = await this.api.getMetaAndAssetCtxs()
      assetCtxs = ctxs
    }
    const pairData = assetCtxs.find(ctx => ctx.coin === pair)

    if (!pairData) {
      this.notifier.warn(`âš ï¸  No data for ${pair}`)
      return
    }

    const midPrice = Number(pairData.midPx || 0)
    if (midPrice === 0) {
      this.notifier.warn(`âš ï¸  Invalid mid price for ${pair}`)
      return
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Get REAL position from Hyperliquid (synced via fills)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const state = this.stateManager.getState()
    const position = state.positions[pair]

    // Calculate order size with tuning
    const adjustedOrderUsd = this.baseOrderUsd * this.tuning.orderUsdFactor

    // Use Kelly Criterion for position sizing (simplified)
    const kellySize = positionSizeUSD({
      winProb: 0.55,
      winRatio: 1.4,
      bankrollUsd: 20000
    })
    const orderSize = Math.min(adjustedOrderUsd, kellySize)

    // Calculate spread with tuning
    const adjustedSpread = this.makerSpreadBps * this.tuning.makerSpreadFactor
    const spreadFactor = adjustedSpread / 10000

    // Calculate bid/ask prices
    const bidPrice = midPrice * (1 - spreadFactor)
    const askPrice = midPrice * (1 + spreadFactor)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROPER MARKET MAKING - Place passive orders and let them fill
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Check existing orders
    const existingOrders = this.trading instanceof LiveTrading
      ? await this.trading.getOpenOrders(pair)
      : []

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHASE MODE: Update orders when price moves significantly
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CHASE_THRESHOLD = 0.05  // 5% - less aggressive (was 0.5%)
    let shouldCancelOrders = false

    if (existingOrders.length > 0) {
      for (const order of existingOrders) {
        const orderPrice = parseFloat(order.limitPx)

        // Check if order is stale based on mid price movement
        const priceDiffFromMid = Math.abs(midPrice - orderPrice) / midPrice

        // For BUY orders: check if we're too far below current bid price
        // For SELL orders: check if we're too far above current ask price
        let isOrderStale = priceDiffFromMid > CHASE_THRESHOLD

        if (order.side === 'B') {
          // BUY order - should be near bidPrice
          const diffFromBid = Math.abs(bidPrice - orderPrice) / bidPrice
          isOrderStale = isOrderStale || diffFromBid > CHASE_THRESHOLD
        } else {
          // SELL order - should be near askPrice
          const diffFromAsk = Math.abs(askPrice - orderPrice) / askPrice
          isOrderStale = isOrderStale || diffFromAsk > CHASE_THRESHOLD
        }

        if (isOrderStale) {
          shouldCancelOrders = true
          this.notifier.info(`   ğŸƒ Chase mode: Order stale, will update (price moved ${(priceDiffFromMid * 100).toFixed(2)}%)`)
          break
        }
      }
    }

    // Check if we have both BID and ASK orders
    const hasBidOrder = existingOrders.some(o => o.side === 'B')
    const hasAskOrder = existingOrders.some(o => o.side === 'A')
    const hasBothOrders = hasBidOrder && hasAskOrder

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // OPTIMIZED: Use batchModify instead of cancel+place
    // This reduces API calls from 4 (cancel BID, cancel ASK, place BID, place ASK)
    // to 1 (modify 2 orders) = 4x faster! ğŸš€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (shouldCancelOrders && hasBothOrders && this.trading instanceof LiveTrading) {
      // Try batch modify ONLY if we have BOTH orders (much faster!)
      this.notifier.info(`   ğŸ”„ Attempting batch modify for ${pair} (BID=$${bidPrice.toFixed(4)}, ASK=$${askPrice.toFixed(4)})`)
      const modified = await this.trading.batchModifyOrders(pair, bidPrice, askPrice, orderSize)

      if (modified) {
        this.notifier.info(`   âš¡ Batch modified 2 orders (4x faster than cancel+place!)`)
        return // Orders updated, we're done!
      } else {
        // Fall back to cancel if modify fails
        this.notifier.info(`   âš ï¸  Batch modify failed, falling back to cancel+place`)
        await this.trading.cancelPairOrders(pair)
      }
    } else if (shouldCancelOrders && hasBothOrders && !this.trading instanceof LiveTrading) {
      // Dry run mode - cancel and recreate
      await this.trading.cancelPairOrders(pair)
    } else if (existingOrders.length > 2 && this.trading instanceof LiveTrading) {
      // Too many orders (more than 2), cancel them
      await this.trading.cancelPairOrders(pair)
    }

    // If we have only 1 order and chase mode detected stale orders,
    // DON'T cancel! Just place the missing order to complete the pair.
    // This prevents the constant cancel loop where we never have both orders.

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DUAL-SIDED MARKET MAKING - Place BOTH bid and ask simultaneously
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Calculate current position exposure
    const currentPositionValue = position ? Math.abs(position.size) : 0
    const maxPositionSizeUsd = orderSize * 4  // Allow up to 4x base order size (MAX_POSITION_MULTIPLIER)

    // Determine if we can place each side based on position limits
    const canPlaceBid = !hasBidOrder && (!position || position.side !== 'short' || currentPositionValue < maxPositionSizeUsd)
    const canPlaceAsk = !hasAskOrder && (!position || position.side !== 'long' || currentPositionValue < maxPositionSizeUsd)

    // PLACE BID ORDER (buy side)
    if (canPlaceBid) {
      this.notifier.info(`ğŸ“Š ${pair} MM: Placing BID $${bidPrice.toFixed(4)} | Spread: ${adjustedSpread}bps`)

      await this.trading.placeOrder(
        pair,
        'buy',
        bidPrice,
        orderSize,
        'limit'
      )
    } else if (!hasBidOrder) {
      this.notifier.info(`   â¸ï¸  BID skipped: Position limit reached ($${currentPositionValue.toFixed(0)} / $${maxPositionSizeUsd.toFixed(0)})`)
    }

    // PLACE ASK ORDER (sell side)
    if (canPlaceAsk) {
      // If we have a long position, ensure we sell above entry for profit
      let targetAskPrice = askPrice
      if (position && position.side === 'long' && position.entryPrice > 0) {
        const minSellPrice = position.entryPrice * (1 + spreadFactor)
        targetAskPrice = Math.max(askPrice, minSellPrice)
        this.notifier.info(`ğŸ“Š ${pair} MM: Placing ASK $${targetAskPrice.toFixed(4)} (entry: $${position.entryPrice.toFixed(4)})`)
      } else {
        this.notifier.info(`ğŸ“Š ${pair} MM: Placing ASK $${targetAskPrice.toFixed(4)} | Spread: ${adjustedSpread}bps`)
      }

      await this.trading.placeOrder(
        pair,
        'sell',
        targetAskPrice,
        orderSize,
        'limit'
      )
    } else if (!hasAskOrder) {
      this.notifier.info(`   â¸ï¸  ASK skipped: Position limit reached ($${currentPositionValue.toFixed(0)} / $${maxPositionSizeUsd.toFixed(0)})`)
    }

    // Positions are updated ONLY via syncPnLFromHyperliquid() in main loop
    this.stateManager.recordExecution(true, Date.now() - startTime)
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Taker Order Strategy - Unlocks API rate limits
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  async executeTakerOrder() {
    const now = Date.now()

    // Check if it's time for a taker order
    if (now - this.lastTakerOrderTime < this.takerOrderIntervalMs) {
      return
    }

    this.notifier.info('âš¡ Executing taker order to unlock rate limits...')

    try {
      // Pick the first active trading pair
      const pairs = this.rotation.getCurrentPairs()
      if (pairs.length === 0) {
        this.notifier.warn('   No active pairs for taker order')
        return
      }

      const pair = pairs[0]

      // Get current market price
      const [meta, assetCtxs] = await this.api.getMetaAndAssetCtxs()
      const pairData = assetCtxs.find(ctx => ctx.coin === pair)

      if (!pairData) {
        this.notifier.warn(`   No data for ${pair}`)
        return
      }

      const midPrice = Number(pairData.midPx || 0)
      if (midPrice === 0) {
        this.notifier.warn(`   Invalid mid price for ${pair}`)
        return
      }

      // Place a taker order (market order with IOC)
      // Alternate between buy and sell to stay balanced
      const isBuy = Math.random() > 0.5

      this.notifier.info(`   ${isBuy ? 'ğŸ’š BUY' : 'ğŸ’” SELL'} ${pair} @ market (${this.takerOrderSizeUsd} USD)`)

      const result = await this.trading.placeOrder(
        pair,
        isBuy ? 'buy' : 'sell',
        midPrice,
        this.takerOrderSizeUsd,
        'market'  // Uses IOC for immediate fill
      )

      if (result.success) {
        this.notifier.info(`   âœ… Taker order executed successfully!`)
        this.notifier.info(`   ğŸ“ˆ Rate limit unlocked: +$${this.takerOrderSizeUsd} volume`)
        this.lastTakerOrderTime = now
      } else {
        this.notifier.warn(`   âš ï¸  Taker order failed`)
      }

    } catch (error) {
      this.notifier.error(`   Error executing taker order: ${error}`)
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Status Logging
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  logStatus(supervisorResult: any) {
    const state = this.stateManager.getState()
    const stats = this.stateManager.getExecStats()

    const successRate = stats.lastN > 0
      ? (stats.success / stats.lastN * 100).toFixed(1)
      : '0.0'

    this.notifier.info('â”€'.repeat(80))
    this.notifier.info(`ğŸ“Š Status | Daily PnL: $${state.dailyPnl.toFixed(2)} | Total: $${state.totalPnl.toFixed(2)}`)
    this.notifier.info(`   Exec: ${successRate}% success (${stats.success}/${stats.lastN}) | Avg latency: ${stats.avgLatencyMs.toFixed(0)}ms`)
    this.notifier.info(`   Tuning: order=${(this.tuning.orderUsdFactor * 100).toFixed(0)}% | spread=${(this.tuning.makerSpreadFactor * 100).toFixed(0)}%`)
    this.notifier.info(`   Health: ${supervisorResult.healthEval.severity}`)

    // Log positions
    const posCount = Object.keys(state.positions).length
    if (posCount > 0) {
      this.notifier.info(`   Positions (${posCount}):`)
      for (const [pair, pos] of Object.entries(state.positions)) {
        this.notifier.info(`     ${pair}: ${pos.side} $${pos.size.toFixed(0)} @ $${pos.entryPrice.toFixed(4)}`)
      }
    }

    this.notifier.info('â”€'.repeat(80))
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Utilities
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN ENTRY POINT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  const bot = new HyperliquidMMBot()

  // Initialize live trading if not in dry run mode
  await bot.initialize()

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('\nğŸ›‘ Received SIGINT, shutting down gracefully...')
    process.exit(0)
  })

  process.on('SIGTERM', () => {
    console.log('\nğŸ›‘ Received SIGTERM, shutting down gracefully...')
    process.exit(0)
  })

  // Start bot
  await bot.mainLoop()
}

// Run
main().catch(error => {
  console.error('Fatal error:', error)
  process.exit(1)
})
